<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Raytracing en un weekend</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="creer_une_image.html"><strong aria-hidden="true">1.</strong> Créer une image</a></li><li class="chapter-item expanded "><a href="la_classe_vec3.html"><strong aria-hidden="true">2.</strong> La classe vec3</a></li><li class="chapter-item expanded "><a href="rayons_camera_arriere_plan.html"><strong aria-hidden="true">3.</strong> Des rayons, une caméra et un arrière-plan</a></li><li class="chapter-item expanded "><a href="ajouter_une_sphere.html"><strong aria-hidden="true">4.</strong> Ajouter une sphère</a></li><li class="chapter-item expanded "><a href="normale_surface_plusieurs_objets.html"><strong aria-hidden="true">5.</strong> Normale à une surface et plusieurs objets</a></li><li class="chapter-item expanded "><a href="antialiasing.html"><strong aria-hidden="true">6.</strong> Antialiasing</a></li><li class="chapter-item expanded "><a href="materiaux_diffus.html"><strong aria-hidden="true">7.</strong> Matériaux diffus</a></li><li class="chapter-item expanded "><a href="metal.html"><strong aria-hidden="true">8.</strong> Métal</a></li><li class="chapter-item expanded "><a href="dielectrique.html"><strong aria-hidden="true">9.</strong> Diélectrique</a></li><li class="chapter-item expanded "><a href="camera_positionnable.html"><strong aria-hidden="true">10.</strong> Caméra positionnable</a></li><li class="chapter-item expanded "><a href="flou_de_focus.html"><strong aria-hidden="true">11.</strong> Flou de focus</a></li><li class="chapter-item expanded "><a href="que_faire_ensuite.html"><strong aria-hidden="true">12.</strong> Que faire-ensuite</a></li><li class="chapter-item expanded "><a href="remerciements.html"><strong aria-hidden="true">13.</strong> Remerciements</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Raytracing en un weekend</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<blockquote>
<p>Ce site est une traduction de l'excellente série de livres sur le raytracing de Peter Shirley. Le ray tracing, ou lancer de rayons en français, est une technique de calcul d'optique par ordinateur, notamment utilisée pour le rendu d'image de synthèse (source : <a href="https://fr.wikipedia.org/wiki/Ray_tracing">Wikipedia</a>). Cette traduction est rendue possible grâce au choix de l'auteur de publier ses écrits sous license permissive CC0 (anciennement payants).</p>
</blockquote>
<p><img src="img/cover.jpg" alt="Couverture" /></p>
<h1><a class="header" href="#point-de-départ" id="point-de-départ">Point de départ</a></h1>
<p>J'ai enseigné pendant plusieurs années la programmation à destination de l'image. Souvent, j'enseigne le ray tracing (lancé de rayons), parce que vous êtes obligé d'écrire tout le code mais vous pouvez quand même obtenir des images super cools. J'ai décidé d'adapter mes notes de cours en manuel, pour que vous puissiez réaliser un programme cool, aussi vite que possible.
Ca ne sera pas un moteur de rendu par lancé de rayons complet mais il sera capable d'illumination indirecte, ce qui a permis aux films de gagner en réalisme. Suivez ces étapes, et l'architecture du ray tracer que vous allez produire sera suffisante pour que vous puissiez construire un ray tracer plus complet par la suite.</p>
<p>Quand quelqu'un parle de &quot;ray tracing&quot;, ça peut vouloir dire plusieurs choses. Ce que je m'aprête à décrire est techniquellement un &quot;path tracer&quot; assez général. Alors que le code que vous allez écrire est très simple (laissons l'ordinateur faire le travail !), je pense que vous serez très satisfait des images que vous pourrez créer avec.</p>
<p>Je vais vous expliquer comme coder un ray tracer dans l'ordre auquel j'ai été habitué à le faire, ainsi que quelques conseils de débogage. A la fin, vous aurez un ray tracer qui produira de belles images. Vous serez capable de faire ça normalement en un weekend. Si ça vous prend plus de temps, ne vous en faites pas. J'utilise le C++ comme langage de programmation, mais vous n'avez pas besoin de faire pareil. Cependant, je vous suggère de le faire, parce que le C++ est rapide, portable et que la plupart des moteurs de rendu de films et jeux vidéos sont écrits en C++. Notez que j'éviterai d'utiliser les fonctionnalités modernes du C++, mais l'héritage et la surcharge d'opérateur sont trop utiles aux ray tracers pour passer outre. Je montre tout le code utilisé, excepté pour quelques calculs très simples pour la classe <code>vec3</code>. Je crois beaucoup au dicton &quot;c'est en faisant que l'on apprend&quot;.</p>
<p>L'intégralité du code source est disponible ici :
<a href="https://github.com/RayTracing/raytracing.github.io/">https://github.com/RayTracing/raytracing.github.io/</a>.</p>
<p>Je suppose que vous êtes un peu familier avec les vecteurs (comme le produit scalaire et l'addition de deux vecteurs). Si vous n'y connaissez rien, faites quelques recherches avant de poursuivre.</p>
<p>Peter Shirley, edited by Steve Hollasch and Trevor David Black</p>
<p>Version 3.0.1, 2020-03-31</p>
<p>Copyright 2018-2020 Peter Shirley. All rights reserved.</p>
<p>Traduction française par Hugues Gaillard.</p>
<h1><a class="header" href="#créer-une-image" id="créer-une-image">Créer une image</a></h1>
<p>A chaque fois que l'on démarre la création d'un moteur de rendu, nous avons besoin de voir une image. La façon la plus simple est d'écrire l'image dans un fichier. Le problème est qu'il existe un innombrable format d'images et que beaucoup d'entre eux sont complexes. Je commence toujours par des fichiers textes ppm. Wikipedia en fait une belle description :</p>
<p><img src="img/format_ppm.png" alt="Format PPM" /></p>
<p>Ecrivons un peu de C++ pour sortir un fichier similaire :</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    const int image_width = 200;
    const int image_height = 100;

    std::cout &lt;&lt; &quot;P3\n&quot; &lt;&lt; image_width &lt;&lt; ' ' &lt;&lt; image_height &lt;&lt; &quot;\n255\n&quot;;

    for (int j = image_height-1; j &gt;= 0; --j) {
        for (int i = 0; i &lt; image_width; ++i) {
            auto r = double(i) / image_width;
            auto g = double(j) / image_height;
            auto b = 0.2;
            int ir = static_cast&lt;int&gt;(255.999 * r);
            int ig = static_cast&lt;int&gt;(255.999 * g);
            int ib = static_cast&lt;int&gt;(255.999 * b);
            std::cout &lt;&lt; ir &lt;&lt; ' ' &lt;&lt; ig &lt;&lt; ' ' &lt;&lt; ib &lt;&lt; '\n';
        }
    }
}
</code></pre>
<p>Il y a plusieurs choses à noter dans ce code :</p>
<ol>
<li>Les pixels sont écrits en lignes, de la gauche vers la droite.</li>
<li>Les lignes sont écrites du haut vers le bas.</li>
<li>Par convention, chaque composant RVB(rouge/vert/bleu ou RGB en anglais) a une valeur allant de 0.0 à 1.0. Nous assouplirons cette contrainte plus tard quand nous utiliserons une plage HDR (high dynamic range), sachant qu'avant de sortir une image HDR nous allons contraindre les valeurs dans l'intervale de zéro à un, donc ce code ne changera pas.</li>
<li>La composante rouge va du noir au maximum de gauche à droite et le vert va du noir en bas, jusqu'au maximum en haut. Le rouge et le vert ensemble forment du jaune, donc on doit s'attendre à ce que coin supérieur droit soit jaune.</li>
</ol>
<p>Parce que le programme n'écrit pas directement dans un fichier mais dans sa sortie standard, nous avons besoin de rédiger celle-ci dans un fichier.
Généralement, c'est fait depuis la ligne de commande en utilisant le chevron '&gt;' pour rediriger la sortie vers un fichier :</p>
<p><code>build\Release\inOneWeekend.exe &gt; image.ppm</code></p>
<p>sous Windows, et pour Mac &amp; Linux :</p>
<p><code>build/inOneWeekend &gt; image.ppm</code></p>
<p>Nous pouvons ouvrir le fichier ainsi créé (avec 'ToyViewer' sur mon Mac par exemple) et nous obtenons le résultat suivant :</p>
<p><img src="img/first_ppm.png" alt="Format PPM" /></p>
<p>Hooray! C'est un peu le 'hello world' en graphique. Si votre image ne ressemble pas à ça, ouvrez le fichier avec un éditeur de texte et regardez à quoi il ressemble. Il devrait commencer par :</p>
<pre><code>P3
200 100
255
0 253 51
1 253 51
2 253 51
3 253 51
5 253 51
6 253 51
7 253 51
8 253 51
</code></pre>
<p>Si ce n'est pas le cas, vous avez peut-être des nouvelles lignes ou quelque chose comme ça. </p>
<p>Si vous voulez produire des formats autres que le PPM, je suis un fan de <code>stb_image.h</code> disponible sur Github.</p>
<h2><a class="header" href="#ajouter-un-indicateur-de-progression" id="ajouter-un-indicateur-de-progression">Ajouter un indicateur de progression</a></h2>
<p>Avant de continuer, ajoutons un indicateur de progression à notre sortie. C'est une façon pratique de suivre la progression d'un long rendu, et aussi une manière d'identifier un lancement bloqué à cause d'une boucle infinie ou d'un autre problème.</p>
<p>Notre programme sort l'image via la sortie standard (<code>std::cout</code>), donc nous laissons ça et on affiche la progression plutôt via la sortie d'erreur (<code>std::cerr</code>) :</p>
<pre><code class="language-cpp">for (int j = image_height-1; j &gt;= 0; --j) {
    std::cerr &lt;&lt; &quot;\rScanlines remaining: &quot; &lt;&lt; j &lt;&lt; ' ' &lt;&lt; std::flush;
    for (int i = 0; i &lt; image_width; ++i) {
        auto r = double(i) / image_width;
        auto g = double(j) / image_height;
        auto b = 0.2;
        int ir = static_cast&lt;int&gt;(255.999 * r);
        int ig = static_cast&lt;int&gt;(255.999 * g);
        int ib = static_cast&lt;int&gt;(255.999 * b);
        std::cout &lt;&lt; ir &lt;&lt; ' ' &lt;&lt; ig &lt;&lt; ' ' &lt;&lt; ib &lt;&lt; '\n';
    }
}
std::cerr &lt;&lt; &quot;\nDone.\n&quot;;
</code></pre>
<h1><a class="header" href="#la-classe-vec3" id="la-classe-vec3">La classe <code>vec3</code></a></h1>
<p>Quasiment tous les programmes graphiques utilisent une ou plusieurs classes pour stocker des vecteurs pour la géométrie et des couleurs. Dans beaucoup de ces systèmes, il s'agit de vecteur 4D (3D + une coordonnée homogène pour la géométrie ou + une composante 'alpha' de transparence pour les couleurs).</p>
<p>Pour notre besoin, 3 coordonnées suffisent. Nous allons donc utiliser la classe <code>vec3</code> pour les couleurs, les positions, les directions, les décalages, etc. Certaines personnes n'aiment pas ça parce que cette méthode ne vous empêche pas de faire des choses stupides, comme ajouter une couleur et une position ensemble. C'est un bon point, mais nous allons choisir la voie du plus simple lorsque ce n'est pas expressement faux.</p>
<p>Voici une implémentation possible de cette classe <code>vec3</code> :</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class vec3 {
    public:
        vec3() : e{0,0,0} {}
        vec3(double e0, double e1, double e2) : e{e0, e1, e2} {}

        double x() const { return e[0]; }
        double y() const { return e[1]; }
        double z() const { return e[2]; }

        vec3 operator-() const { return vec3(-e[0], -e[1], -e[2]); }
        double operator[](int i) const { return e[i]; }
        double&amp; operator[](int i) { return e[i]; }

        vec3&amp; operator+=(const vec3 &amp;v) {
            e[0] += v.e[0];
            e[1] += v.e[1];
            e[2] += v.e[2];
            return *this;
        }

        vec3&amp; operator*=(const double t) {
            e[0] *= t;
            e[1] *= t;
            e[2] *= t;
            return *this;
        }

        vec3&amp; operator/=(const double t) {
            return *this *= 1/t;
        }

        double length() const {
            return sqrt(length_squared());
        }

        double length_squared() const {
            return e[0]*e[0] + e[1]*e[1] + e[2]*e[2];
        }

        void write_color(std::ostream &amp;out) {
            // Write the translated [0,255] value of each color component.
            out &lt;&lt; static_cast&lt;int&gt;(255.999 * e[0]) &lt;&lt; ' '
                &lt;&lt; static_cast&lt;int&gt;(255.999 * e[1]) &lt;&lt; ' '
                &lt;&lt; static_cast&lt;int&gt;(255.999 * e[2]) &lt;&lt; '\n';
        }

    public:
        double e[3];
};
</code></pre>
<p>Nous utilisons des <code>double</code> ici, mais certains ray tracers fonctionnent avec des <code>float</code>. C'est selon votre propre goût. La seconde partie du fichier header contient des fonctions utilitaires relatives aux vecteurs :</p>
<pre><code class="language-cpp">// vec3 Utility Functions

inline std::ostream&amp; operator&lt;&lt;(std::ostream &amp;out, const vec3 &amp;v) {
    return out &lt;&lt; v.e[0] &lt;&lt; ' ' &lt;&lt; v.e[1] &lt;&lt; ' ' &lt;&lt; v.e[2];
}

inline vec3 operator+(const vec3 &amp;u, const vec3 &amp;v) {
    return vec3(u.e[0] + v.e[0], u.e[1] + v.e[1], u.e[2] + v.e[2]);
}

inline vec3 operator-(const vec3 &amp;u, const vec3 &amp;v) {
    return vec3(u.e[0] - v.e[0], u.e[1] - v.e[1], u.e[2] - v.e[2]);
}

inline vec3 operator*(const vec3 &amp;u, const vec3 &amp;v) {
    return vec3(u.e[0] * v.e[0], u.e[1] * v.e[1], u.e[2] * v.e[2]);
}

inline vec3 operator*(double t, const vec3 &amp;v) {
    return vec3(t*v.e[0], t*v.e[1], t*v.e[2]);
}

inline vec3 operator*(const vec3 &amp;v, double t) {
    return t * v;
}

inline vec3 operator/(vec3 v, double t) {
    return (1/t) * v;
}

inline double dot(const vec3 &amp;u, const vec3 &amp;v) {
    return u.e[0] * v.e[0]
         + u.e[1] * v.e[1]
         + u.e[2] * v.e[2];
}

inline vec3 cross(const vec3 &amp;u, const vec3 &amp;v) {
    return vec3(u.e[1] * v.e[2] - u.e[2] * v.e[1],
                u.e[2] * v.e[0] - u.e[0] * v.e[2],
                u.e[0] * v.e[1] - u.e[1] * v.e[0]);
}

inline vec3 unit_vector(vec3 v) {
    return v / v.length();
}
</code></pre>
<p>Maintenant, nous pouvons changer notre fonction <code>main</code> pour utiliser cette classe :</p>
<pre><code class="language-cpp">#include &quot;vec3.h&quot;

#include &lt;iostream&gt;

int main() {
    const int image_width = 200;
    const int image_height = 100;

    std::cout &lt;&lt; &quot;P3\n&quot; &lt;&lt; image_width &lt;&lt; ' ' &lt;&lt; image_height &lt;&lt; &quot;\n255\n&quot;;

    for (int j = image_height-1; j &gt;= 0; --j) {
        std::cerr &lt;&lt; &quot;\rScanlines remaining: &quot; &lt;&lt; j &lt;&lt; ' ' &lt;&lt; std::flush;
        for (int i = 0; i &lt; image_width; ++i) {
            vec3 color(double(i)/image_width, double(j)/image_height, 0.2);
            color.write_color(std::cout);
        }
    }

    std::cerr &lt;&lt; &quot;\nDone.\n&quot;;
}
</code></pre>
<h1><a class="header" href="#des-rayons-une-caméra-et-un-arrière-plan" id="des-rayons-une-caméra-et-un-arrière-plan">Des rayons, une caméra et un arrière-plan</a></h1>
<p>Le point commun de tous les ray tracers, c'est une classe permettant de modélisation un rayon de lumière (ray) et un calcul déterminant la couleur vue le long de ce rayon.</p>
<p>Nous pouvons modéliser un rayon comme une fonction :</p>
<p>\[ p(t)=a+t \vec{b} \]</p>
<p>Ici \( p \) est une position 3D le long d'une ligne 3D. \( a \) est l'origine du rayon et \( \vec{b} \) est la direction du rayon. Le rayon a également un paramètre \( t \), un nombre réel (<code>double</code> dans le code).
Fournir un \( t \) différent et \( p(t) \) déplacera le point le long du rayon. Ajoutez un \( t \) négatif et on peut se déplacer n'importe où le long de cette ligne 3D. Pour un \( t \) positif, on peut se déplacer seulement sur la partie en face de \( a \), et c'est ce qu'on appelle souvent une demi-ligne ou rayon.</p>
<p><img src="img/interpolation_lineaire.jpg" alt="Interpolation linéaire" /></p>
<p>La fonction \( p(t) \) peut se modéliser comme une classe <code>ray</code> pour laquelle on implémente une fonction <code>ray::at(t)</code> :</p>
<pre><code class="language-cpp">#ifndef RAY_H
#define RAY_H

#include &quot;vec3.h&quot;

class ray {
    public:
        ray() {}
        ray(const vec3&amp; origin, const vec3&amp; direction)
            : orig(origin), dir(direction)
        {}

        vec3 origin() const    { return orig; }
        vec3 direction() const { return dir; }

        vec3 at(double t) const {
            return orig + t*dir;
        }

    public:
        vec3 orig;
        vec3 dir;
};

#endif
</code></pre>
<p>Maintenant, nous sommes fins prêts à implémenter un ray tracer. A son coeur, le ray tracer envoie des rayons pour chaque pixel de l'image et calcule la couleur perçue dans la direction de ces rayons. Les étapes sont donc au nombre de 3 :</p>
<ol>
<li>calculer le rayon depuis l'oeil (la caméra) au pixel</li>
<li>déterminer quels objets le rayon va traverser (calcul d'intersection)</li>
<li>calculer une couleur sur ce point d'intersection.</li>
</ol>
<p>Quand je développe un ray tracer, je commence par créer une caméra simple pour pouvoir visualiser et débugger mon code. Je fais également une petite fonction <code>color(ray)</code> qui retourne la couleur de l'arrière-plan (un simple dégradé).</p>
<p>Je tombe souvent sur des problèmes quand j'utilise des images carrées pour déboguer car je transpose \(x\) et \(y\) trop souvent, donc je fais des images en \(200\times100\). </p>
<p>Je mets &quot;l'oeil&quot; (le centre de la caméra) aux coordonnées \((0,0,0)\). Je place l'axe \(y\) qui pointe vers le haut et l'axe \(x\) dirigé vers la droite. Pour respecter la convention d'un système de coordonées 'main droite', je place un axe \(z\) négatif vers l'écran. Je balaye l'écran depuis le coin inférieur gauche et j'utilise 2 vecteurs de décalage le long des côtés de l'écran pour déplacer le bout du rayon sur la surface de l'écran. Notez que le vecteur de direction n'est pas un vecteur de longueur normalisé (longueur unitaire) parce que je pense que ça rend le code plus simple et légèrement plus rapide.</p>
<p><img src="img/geometrie_camera.jpg" alt="Géométrie de la caméra" /></p>
<p>Dessous en code, le rayon \(r\) est approximativement dirigé vers les centres des pixels (je ne me focalise pas sur l'exatitude pour l'instant car nous ajouterons l'antialiasing plus tard).</p>
<pre><code class="language-cpp">#include &quot;ray.h&quot;

#include &lt;iostream&gt;

vec3 ray_color(const ray&amp; r) {
    vec3 unit_direction = unit_vector(r.direction());
    auto t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);
}

int main() {
    const int image_width = 200;
    const int image_height = 100;

    std::cout &lt;&lt; &quot;P3\n&quot; &lt;&lt; image_width &lt;&lt; &quot; &quot; &lt;&lt; image_height &lt;&lt; &quot;\n255\n&quot;;
    vec3 lower_left_corner(-2.0, -1.0, -1.0);
    vec3 horizontal(4.0, 0.0, 0.0);
    vec3 vertical(0.0, 2.0, 0.0);
    vec3 origin(0.0, 0.0, 0.0);
    for (int j = image_height-1; j &gt;= 0; --j) {
        std::cerr &lt;&lt; &quot;\rScanlines remaining: &quot; &lt;&lt; j &lt;&lt; ' ' &lt;&lt; std::flush;
        for (int i = 0; i &lt; image_width; ++i) {
            auto u = double(i) / image_width;
            auto v = double(j) / image_height;
            ray r(origin, lower_left_corner + u*horizontal + v*vertical);
            vec3 color = ray_color(r);
            color.write_color(std::cout);
        }
    }

    std::cerr &lt;&lt; &quot;\nDone.\n&quot;;
}
</code></pre>
<p>La fonction <code>ray_color(ray)</code> mélange linéairement du blanc et du bleu selon la hauteur de la coordonnée \(y\) <em>après</em> avoir redimensionner la direction du rayon en vecteur unitaire (normalisé) (donc \(-1.0 &lt; y &lt; 1.0\)).
Parce qu'on est en train de regarder la hauteur \(y\) après avoir normalisé le vecteur, vous remarquerez un dégradé horizontal vers la couleur en plus du dégradé vertical.</p>
<p>Ensuite, je redimensionne grâce une astuce classique de manière à ce que \(0.0 \leq t \leq 1.0\). Quand \(t=1.0\) je veux du bleu. Quand \(t=0.0\), je veux du blanc. Et entre, je veux un dégradé. Cela forme un dégradé linéaire, ou interpolation linéaire, ou 'lerp' (de <em>linear interpolation</em>). Une interpolation linéaire est toujours de la forme :</p>
<p>\[ \text{blendedValue} = (1-t) \times \text{startValue} + t \times \text{endValue} \]</p>
<p>avec \(t\) allant de 0 à 1. Dans notre cas, le code suivant produit :</p>
<p><img src="img/degrade_bleu_blanc.png" alt="Dégradé du bleu au blanc qui dépend du rayon de coordonnées Y" /></p>
<h1><a class="header" href="#ajouter-une-sphère" id="ajouter-une-sphère">Ajouter une sphère</a></h1>
<p>Ajoutons un seul objet à notre ray tracer. Beaucoup de personnes utilisent des sphères dans les ray tracers car calculer si un rayon frappe une sphère est assez simple. Rappelez-vous de l'équation pour une sphère centrée sur l'origine du rayon \(R\) est \(x^2 + y^2 + z^2 = R^2\). D'une autre façon, pour un point \((x,y,z)\) placé sur la sphère, alors \(x^2+y^2+z^2=R^2\).
Si le point \((x,y,z)\) est à <em>l'intérieur</em> de la sphère, alors \(x^2+y^2+z^2 \lt R^2\) et si un point \((x,y,z)\) est à <em>l'extérieur</em> de la sphère, alors \(x^2+y^2+z^2 \gt R^2\).</p>
<p>Ca se complexifie un peu si le centre de la sphère est donnée par \( (c_x, c_y, c_z)\) :</p>
<p>\[ (x-c_x)^2 + (y-c_y)^2 + (z-c_z)^2 = R^2 \]</p>
<p>Dans le graphisme, vous voulez quasiment toujours que vos formules soient en termes de vecteurs pour que tous les trucs x/y/z soient gérés par la classe <code>vec3</code>. Ainsi, notez que le vecteur de centre \( c=(c_x,c_y,c_z) \) au point \(P=(x,y,z)\) est noté \( (p-c) \). Donc :</p>
<p>\[ (p-c) \cdot (p-c) = (x-c_x)^2 + (y-c_y)^2 + (z-c_z)^2 \]</p>
<p>L'équation de la sphère est terme de vecteurs s'écrit alors :</p>
<p>\[ (p-c) \cdot (p-c) = R^2 \]</p>
<p>On peut lire cette équation comme &quot;tout point \(p\) qui satisfait l'équation est sur la sphère&quot;.</p>
<p>Nous voulons savoir si notre rayon \( p(t)=a+t \vec{b} \) touche la sphère quelque part. S'il touche la sphère, il y a un \(t\) pour lequel \(p(t)\) satisfait l'équation de la sphère.
Donc, nous cherchons un \(t\) où la relation suivante est vraie :</p>
<p>\[ (p(t) - c) \cdot (p(t) - c) = R^2 \]</p>
<p>ou, sous sa forme développée du rayon \(p(t)\) :</p>
<p>\[ (a+t\vec{b} - c) \cdot (a+t\vec{b} - c)=R^2 \]</p>
<p>En suivant les règles de l'algèbre appliquées aux vecteurs, si nous développons cette équation et que nous déplaçons tous ses termes à gauche, nous obtenons :</p>
<p>\[ t^2\vec{b} \cdot \vec{b} + 2t\vec{b} \cdot (a \vec{-} c) + (a \vec{-} c) \cdot (a \vec{-} c) - R^2 = 0 \]</p>
<p>Les vecteurs et R dans cette équation sont tous constants et connus. L'inconnu est \(t\) et l'équation est quadratique, comme vous l'avez surement vu en cours de maths au lycée. Nous pouvons résoudre cette équation pour \(t\)  et il y a une racine qui est soit positive (donc 2 solutions réelles), soit négative (aucune solution dans l'espace des réels) ou zéro (une seule solution). Dans le graphisme, l'algèbre a toujours une relation très directe avec la géométrie.</p>
<p>Ce que nous avons est :</p>
<p><img src="img/sphere_rayons.jpg" alt="Les résultats de l'intersection d'une sphère" /></p>
<p>Si nous transposons ces maths en code dans notre programme, nous pouvons tester ça en colorant en rouge chaque pixel qui touche une petite sphère que nous plaçons à \(-1\) sur l'axe Z.</p>
<pre><code class="language-cpp">bool hit_sphere(const vec3&amp; center, double radius, const ray&amp; r) {
    vec3 oc = r.origin() - center;
    auto a = dot(r.direction(), r.direction());
    auto b = 2.0 * dot(oc, r.direction());
    auto c = dot(oc, oc) - radius*radius;
    auto discriminant = b*b - 4*a*c;
    return (discriminant &gt; 0);
}

vec3 ray_color(const ray&amp; r) {
    if (hit_sphere(vec3(0,0,-1), 0.5, r))
        return vec3(1, 0, 0);
    vec3 unit_direction = unit_vector(r.direction());
    auto t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);
}
</code></pre>
<p>Nous obtenons :</p>
<p><img src="img/sphere_rouge.png" alt="Une simple sphère rouge" /></p>
<p>Il manque encore toute sorte de choses, comme le <em>shading</em> (l'ombrage), les rayons de réflexions, d'autres objets... mais nous avons déjà fait plus que la moitié du chemin depuis que nous avons commencé ! Une chose à garder en mémoire est que nous avons testé si le rayon touche la sphère (ou pas), mais les solutions de \(t&lt;0\) fonctionnent biens également. Si vous changez le centre de la sphère à \(z=+1\) vous aurez exactement la même image parce que vous voyez les choses derrière vous... Ce n'est pas normal, nous corrigerons ça bientôt.</p>
<h1><a class="header" href="#normale-à-une-surface-et-plusieurs-objets" id="normale-à-une-surface-et-plusieurs-objets">Normale à une surface et plusieurs objets</a></h1>
<p>Premièrement, définissons ce qu'est une normale, puis utilisons ce concept pour nuancer/ombrager les objets.
Une normale est un vecteur qui est perpendiculaire à la surface au point d'intersection. Il y a deux façons de concevoir des normales.
La première est de faire une normale à partir d'un vecteur de longueur unitaire. C'est pratique pour nuancer/ombrager donc je dirai que c'est une bonne solution, mais comme dit précédemment, je ne vais pas le faire dans le code. Ca peut entrainer des bugs difficiles à débusquer.</p>
<p>Pour une sphère, la normale extérieure est dans la direction du point d'impact, auquel on aurait soustrait la position du centre :</p>
<p><img src="img/normale_sphere.jpg" alt="Normale à une sphère" /></p>
<p>Si on prend la terre pour exemple, ça implique donc que le vecteur qui part du centre de la terre au point jusqu'à vous pointe vers le haut.</p>
<p>Implémentons ça et voyons le résultat.</p>
<p>Pour l'instant, nous n'avons aucune lumière donc nous allons devoir visualiser les normales en utilisant un jeu de couleurs. 
Une astuce utilisée fréquemment pour la visualisation de normales (car facile et intuitif d'assumer que \(N\) est un vecteur de longueur unitaire, donc chacun de ses composants est entre -1 et 1) est d'associer à chaque composant de l'intervalle 0 à 1, la valeur x/y/z en r/g/b. 
Pour une normale, nous avons besoin du point d'intersection, pas seulement savoir si le rayon a touché ou non la sphère. Nous allons assumer que la normale est désignée par le point d'intersection le plus proche (le plus petit \(t\) possible).</p>
<p>Notre code modifié qui nous permet de calculer et visualiser \(N\) est le suivant :</p>
<pre><code class="language-cpp">double hit_sphere(const vec3&amp; center, double radius, const ray&amp; r) {
    vec3 oc = r.origin() - center;
    auto a = dot(r.direction(), r.direction());
    auto b = 2.0 * dot(oc, r.direction());
    auto c = dot(oc, oc) - radius*radius;
    auto discriminant = b*b - 4*a*c;
    if (discriminant &lt; 0) {
        return -1.0;
    } else {
        return (-b - sqrt(discriminant) ) / (2.0*a);
    }
}

vec3 ray_color(const ray&amp; r) {
    auto t = hit_sphere(vec3(0,0,-1), 0.5, r);
    if (t &gt; 0.0) {
        vec3 N = unit_vector(r.at(t) - vec3(0,0,-1));
        return 0.5*vec3(N.x()+1, N.y()+1, N.z()+1);
    }
    vec3 unit_direction = unit_vector(r.direction());
    t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);
}
</code></pre>
<p>Ce qui nous donne l'image suivante :</p>
<p><img src="img/visualisation_normales_sphere.png" alt="Visualisation normales d'une sphère" /></p>
<p>Chaque pixel de la sphère est coloré selon son vecteur normal. </p>
<p>Revisitons l'équation de l'intersection d'un rayon et d'une sphère, précédemment nous avions :</p>
<pre><code class="language-cpp">vec3 oc = r.origin() - center;
auto a = dot(r.direction(), r.direction());
auto b = 2.0 * dot(oc, r.direction());
auto c = dot(oc, oc) - radius*radius;
auto discriminant = b*b - 4*a*c;
</code></pre>
<p>Déjà, souvenez-vous qu'un vecteur dont on fait le produit scalaire (<em>dot product</em>) avec lui-même est égal au carré de la longueur de ce vecteur.
Deuxièmement, notez comment l'équation suivante a un facteur 2 pour \(b\). Observez ce qu'il se passe à l'équation quadratique si \(b=2h\) :</p>
<p>\[ -b \pm \sqrt{b^2 - 4ac} \over{2a}\]</p>
<p>\[ = \frac{-2h \pm \sqrt{(2h)^2 - 4ac}}{2a}\]</p>
<p>\[ = \frac{-2h \pm 2\sqrt{h^2 - ac}}{2a}\]</p>
<p>\[ = \frac{-h \pm \sqrt{h^2 - ac}}{a}\]</p>
<p>En utilisant ces observations, nous pouvons simplifier le code par ça :</p>
<pre><code class="language-cpp">vec3 oc = r.origin() - center;
auto a = r.direction().length_squared();
auto half_b = dot(oc, r.direction());
auto c = oc.length_squared() - radius*radius;
auto discriminant = half_b*half_b - a*c;

if (discriminant &lt; 0) {
    return -1.0;
} else {
    return (-half_b - sqrt(discriminant) ) / a;
}
</code></pre>
<p>Maintenant, comment gérer plusieurs sphères ? Il serait assez tentant de stocker un tableau de sphères, une solution très propre serait d'avoir une classe abtraite (que l'on ne peut pas instancier) pour chaque objet qu'un rayon pourrait traverser. De cette manière, une sphère, ou une liste de sphères pourraient être traversées. Le nom à donner à cette classe est un vrai dilemme : si on l'appelle objet ce n'est pas un bon nom puisqu'on fait de la programmation orientée objet par exemple. &quot;Surface&quot; est souvent utilisé, sauf que parfois nous voulons gérer des volumes... &quot;hittable&quot; (de l'anglais 'hit', touché, 'hittable', que l'on peut toucher) met en avant la principale fonction membre : 'hit'. Je n'aime aucun de ces choix mais partons sur 'hittable'.</p>
<p>Cette classe <em>hittable</em> aura donc une méthode qui prend en paramètre un rayon (<em>ray</em>). La plupart des raytracers a jugé bon d'ajouter un intervalle valide pour la valeur \(t\) pour que \(t\) soit compris entre \(t_{min}\) et \(t_{max}\). Si \(t\) ne respecte pas \(t_{min} &lt; t &lt; t_{max}\), le &quot;hit&quot; n'est pas détecté. Une question qui apparait maintenant est : doit-on calculer la normale si le rayon touche quelque chose ? On pourrait finir par toucher quelque chose de plus proche et du coup, nous n'aurions besoin que de la normale de l'objet le plus proche. Je vais partir sur la solution simple et calculer un lot de petites choses que je stockerai dans une structure.</p>
<p>Voici la classe abstraite 'hittable' :</p>
<pre><code class="language-cpp">#ifndef HITTABLE_H
#define HITTABLE_H

#include &quot;ray.h&quot;

struct hit_record {
    vec3 p;
    vec3 normal;
};

class hittable {
    public:
        virtual bool hit(const ray&amp; r, double t_min, double t_max, hit_record&amp; rec) const = 0;
};

#endif
</code></pre>
<p>Et voici l'implémentation pour la sphère :</p>
<pre><code class="language-cpp">#ifndef SPHERE_H
#define SPHERE_H

#include &quot;hittable.h&quot;
#include &quot;vec3.h&quot;

class sphere: public hittable {
    public:
        sphere() {}
        sphere(vec3 cen, double r) : center(cen), radius(r) {};

        virtual bool hit(const ray&amp; r, double tmin, double tmax, hit_record&amp; rec) const;

    public:
        vec3 center;
        double radius;
};

bool sphere::hit(const ray&amp; r, double t_min, double t_max, hit_record&amp; rec) const {
    vec3 oc = r.origin() - center;
    auto a = r.direction().length_squared();
    auto half_b = dot(oc, r.direction());
    auto c = oc.length_squared() - radius*radius;
    auto discriminant = half_b*half_b - a*c;

    if (discriminant &gt; 0) {
        auto root = sqrt(discriminant);
        auto temp = (-half_b - root)/a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.at(rec.t);
            rec.normal = (rec.p - center) / radius;
            return true;
        }
        temp = (-half_b + root) / a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.at(rec.t);
            rec.normal = (rec.p - center) / radius;
            return true;
        }
    }
    return false;
}


#endif
</code></pre>
<p>Une deuxième question que l'on pourrait se poser est la direction dans laquelle les normales doivent toujours pointer. Jusqu'à présent, la normale trouvée sera toujours dans la direction du centre du point d'intersection (la normale pointe vers l'extérieur). Si le rayon intersectionne la sphère depuis l'extérieur, la normale pointera à l'opposée du rayon. Si le rayon intersectionne la sphère depuis l'intérieur, la normale (qui pointe toujours vers l'extérieure) pointera vers le rayon. De plus, nous pouvons avoir la normale qui pointe toujours à l'opposée du rayon. Si le rayon est à l'extérieur de la sphère, la normale pointera à l'extérieure, mais si le rayon est à l'intérieur de la sphère, la normale pointera vers l'intérieur.</p>
<p><img src="img/directions_possibles_normale.jpg" alt="Les différentes directions possibles que peut prendre la normale" /></p>
<p>Nous devons choisir une de ses possibilités et s'y tenir, car nous voudrons éventuellement déterminer de quel côté de la surface un rayon provient. C'est important pour les objets qui sont rendus de façon différente de chaque côté, comme du texte qu'on écrirait sur une feuille de papier ou pour des objets qui ont un intérieur et un extérieur, comme des boules de verre.</p>
<p>Si nous décidons d'avoir les normales qui pointent toujours vers l'extérieur, nous avons besoin de déterminer de quel côté le rayon est pour le colorer. On peut le déterminer en comparant le rayon avec la normale. Si le rayon et la normale pointent dans la même direction, le rayon est à l'intérieur de l'objet. Ca peut être déterminé en prenant le produit scalaire des deux vecteurs : si le produit scalaire est positif, le rayon est à l'intérieur de la sphère.</p>
<pre><code class="language-cpp">if (dot(ray_direction, outward_normal) &gt; 0.0) {
    // ray is inside the sphere
    ...
} else {
    // ray is outside the sphere
    ...
}
</code></pre>
<p>Si nous décidons d'avoir les normales qui pointent dans la direction opposée au rayon, nous ne pouvons pas utiliser le produit scalaire pour déterminer de quel côté de la surface le rayon est. A la place, nous avons besoin de stocker l'information :</p>
<pre><code class="language-cpp">bool front_face;
if (dot(ray_direction, outward_normal) &gt; 0.0) {
    // ray is inside the sphere
    normal = -outward_normal;
    front_face = false;
}
else {
    // ray is outside the sphere
    normal = outward_normal;
    front_face = true;
}
</code></pre>
<p>La décision de savoir si vous souhaitez avoir les normales qui pointent toujours vers l'extérieure ou toujours à l'opposées du rayon est liée à la décision de savoir si vous voulez déterminer le côté de la surface au moment de la géométrie ou au moment de la coloration. Dans ce livre, nous avons plus de &quot;matériaux&quot; (type de surface) que nous aurons de types de géométrie, donc nous choisirons la voie de la facilité et nous déterminerons l'endroit/l'envers de la surface au moment de la géométrie. C'est juste une question de goût et vous trouverez les deux implémentations dans la littérature.</p>
<p>Nous ajoutons la variable booléenne <code>front_face</code> à la structure <code>hit_record</code>. Je sais que nous aurons besoin plus tard de flou de mouvement, donc j'ajoute également une variable <code>t</code> pour stocker le temps.</p>
<pre><code class="language-cpp">#ifndef HITTABLE_H
#define HITTABLE_H

#include &quot;ray.h&quot;

struct hit_record {
    vec3 p;
    vec3 normal;
    double t;
    bool front_face;

    inline void set_face_normal(const ray&amp; r, const vec3&amp; outward_normal) {
        front_face = dot(r.direction(), outward_normal) &lt; 0;
        normal = front_face ? outward_normal :-outward_normal;
    }
};

class hittable {
    public:
        virtual bool hit(const ray&amp; r, double t_min, double t_max, hit_record&amp; rec) const = 0;
};

#endif
</code></pre>
<p>Et ensuite, nous ajoutons la détermination du côté de la surface dans la classe :</p>
<pre><code class="language-cpp">bool sphere::hit(const ray&amp; r, double t_min, double t_max, hit_record&amp; rec) const {
    vec3 oc = r.origin() - center;
    auto a = r.direction().length_squared();
    auto half_b = dot(oc, r.direction());
    auto c = oc.length_squared() - radius*radius;
    auto discriminant = half_b*half_b - a*c;

    if (discriminant &gt; 0) {
        auto root = sqrt(discriminant);
        auto temp = (-half_b - root)/a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.at(rec.t);
            vec3 outward_normal = (rec.p - center) / radius;
            rec.set_face_normal(r, outward_normal);
            return true;
        }
        temp = (-half_b + root) / a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.at(rec.t);
            vec3 outward_normal = (rec.p - center) / radius;
            rec.set_face_normal(r, outward_normal);
            return true;
        }
    }
    return false;
}
</code></pre>
<p>Nous ajoutons une liste d'objets :</p>
<pre><code class="language-cpp">#ifndef HITTABLE_LIST_H
#define HITTABLE_LIST_H

#include &quot;hittable.h&quot;
#include &lt;memory&gt;
#include &lt;vector&gt;

using std::shared_ptr;
using std::make_shared;

class hittable_list: public hittable {
    public:
        hittable_list() {}
        hittable_list(shared_ptr&lt;hittable&gt; object) { add(object); }

        void clear() { objects.clear(); }
        void add(shared_ptr&lt;hittable&gt; object) { objects.push_back(object); }

        virtual bool hit(const ray&amp; r, double tmin, double tmax, hit_record&amp; rec) const;

    public:
        std::vector&lt;shared_ptr&lt;hittable&gt;&gt; objects;
};

bool hittable_list::hit(const ray&amp; r, double t_min, double t_max, hit_record&amp; rec) const {
    hit_record temp_rec;
    bool hit_anything = false;
    auto closest_so_far = t_max;

    for (const auto&amp; object : objects) {
        if (object-&gt;hit(r, t_min, closest_so_far, temp_rec)) {
            hit_anything = true;
            closest_so_far = temp_rec.t;
            rec = temp_rec;
        }
    }

    return hit_anything;
}

#endif
</code></pre>
<h2><a class="header" href="#quelques-nouvelles-fonctionnalités-du-c" id="quelques-nouvelles-fonctionnalités-du-c">Quelques nouvelles fonctionnalités du C++</a></h2>
<p>La classe <code>hittable_list</code> utilise deux fonctionnalités du C++ qui peuvent vous sembler inconnu si vous n'avez pas l'habitude de ce langage : <code>vector</code> et <code>shared_ptr</code>.</p>
<p><code>shared_ptr&lt;type&gt;</code> est un pointeur vers un type alloué, avec une sémantique de comptage de références. Chaque fois que vous attribuez sa valeur à un autre pointeur partagé (<code>shared_ptr</code>, généralement avec une affectation simple), le nombre de références est incrémenté. Lorsque les pointeurs partagés sortent de la portée (comme à la fin d'un bloc ou d'une fonction), le nombre de références est décrémenté. Une fois que le nombre atteint zéro, l'objet est supprimé de la mémoire.</p>
<p>Habituellement, un <code>shared_ptr</code> est d'abord initialisé avec un un objet nouvellement alloué :</p>
<pre><code class="language-cpp">shared_ptr&lt;double&gt; double_ptr = make_shared&lt;double&gt;(0.37);
shared_ptr&lt;vec3&gt;   vec3_ptr   = make_shared&lt;vec3&gt;(1.414214, 2.718281, 1.618034);
shared_ptr&lt;sphere&gt; sphere_ptr = make_shared&lt;sphere&gt;(vec3(0,0,0), 1.0);
</code></pre>
<p><code>make_shared&lt;thing&gt;(thing_constructor_params ...)</code> alloue une nouvelle instance du type <code>thing</code> en utilisant les paramètres de constructeur. Cette fonction retourne un <code>shared_ptr&lt;thing&gt;</code>.</p>
<p>Puisque le type peut automatiquement être inféré par le type de retour de <code>make_shared&lt;type&gt;(...)</code>, les lignes au-dessus peuvent être reécrites plus simplement en utilisant le mot-clé <code>auto</code> :</p>
<pre><code class="language-cpp">auto double_ptr = make_shared&lt;double&gt;(0.37);
auto vec3_ptr   = make_shared&lt;vec3&gt;(1.414214, 2.718281, 1.618034);
auto sphere_ptr = make_shared&lt;sphere&gt;(vec3(0,0,0), 1.0);
</code></pre>
<p>Nous utiliserons ces pointeurs partagés dans notre code, car ça permet à plusieurs géométries de partager une même instance (par exemple, un lot de sphères qui utilise le même matériau/texture) et parce que ça rend la gestion de la mémoire automatique et plus facile à comprendre.</p>
<p><code>std::shared_ptr</code> est inclus avec le header <code>&lt;memory&gt;</code>.</p>
<p>La deuxième fonctionnalité du C++ qui peut vous sembler non familiaire est le <code>std::vector</code>. C'est une sorte de tableau générique. Dans le code au-dessus, nous utilisons une collection de pointeurs vers <code>hittable</code>. <code>std::vector</code> s'aggrandie automatiquement à chaque fois qu'une valeur est ajoutée : <code>objects.push_back(object)</code> ajoute une valeur à la fin du <code>std::vector</code>.</p>
<p><code>std::vector</code> est inclus avec le header <code>&lt;vector&gt;</code>.</p>
<p>Finalement, l'instruction <code>using</code> indique au compilateur que nous obtenons <code>shared_ptr</code> et <code>make_shared</code> depuis la librairie standard <code>std</code>, donc nous n'avons pas besoin de les préfixer avec <code>std::</code> à chaque fois que nous y faisons référence.</p>
<h2><a class="header" href="#constantes-usuelles-et-fonctions-utilitaires" id="constantes-usuelles-et-fonctions-utilitaires">Constantes usuelles et fonctions utilitaires</a></h2>
<p>Nous avons besoin de quelques constantes mathématiques donc nous les définissons dans un fichier d'en-tête qui leurs sont propres. Pour l'instant, nous n'avons besoin que de la valeur infinie, mais nous allons également y définir Pi. Nous allons également placer des fonctions utilitaires dans l'en-tête <em>rtweekend.h</em> .</p>
<pre><code class="language-cpp">#ifndef RTWEEKEND_H
#define RTWEEKEND_H

#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;limits&gt;
#include &lt;memory&gt;


// Usings

using std::shared_ptr;
using std::make_shared;

// Constants

const double infinity = std::numeric_limits&lt;double&gt;::infinity();
const double pi = 3.1415926535897932385;

// Utility Functions

inline double degrees_to_radians(double degrees) {
    return degrees * pi / 180;
}

inline double ffmin(double a, double b) { return a &lt;= b ? a : b; }
inline double ffmax(double a, double b) { return a &gt;= b ? a : b; }

// Common Headers

#include &quot;ray.h&quot;
#include &quot;vec3.h&quot;

#endif
</code></pre>
<p>Et le nouveau <code>main</code> :</p>
<pre><code class="language-cpp">#include &quot;rtweekend.h&quot;

#include &quot;hittable_list.h&quot;
#include &quot;sphere.h&quot;

#include &lt;iostream&gt;
vec3 ray_color(const ray&amp; r, const hittable&amp; world) {
    hit_record rec;
    if (world.hit(r, 0, infinity, rec)) {
        return 0.5 * (rec.normal + vec3(1,1,1));
    }
    vec3 unit_direction = unit_vector(r.direction());
    auto t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);
}

int main() {
    const int image_width = 200;
    const int image_height = 100;

    std::cout &lt;&lt; &quot;P3\n&quot; &lt;&lt; image_width &lt;&lt; ' ' &lt;&lt; image_height &lt;&lt; &quot;\n255\n&quot;;

    vec3 lower_left_corner(-2.0, -1.0, -1.0);
    vec3 horizontal(4.0, 0.0, 0.0);
    vec3 vertical(0.0, 2.0, 0.0);
    vec3 origin(0.0, 0.0, 0.0);

    hittable_list world;
    world.add(make_shared&lt;sphere&gt;(vec3(0,0,-1), 0.5));
    world.add(make_shared&lt;sphere&gt;(vec3(0,-100.5,-1), 100));

    for (int j = image_height-1; j &gt;= 0; --j) {
        std::cerr &lt;&lt; &quot;\rScanlines remaining: &quot; &lt;&lt; j &lt;&lt; ' ' &lt;&lt; std::flush;
        for (int i = 0; i &lt; image_width; ++i) {
            auto u = double(i) / image_width;
            auto v = double(j) / image_height;
            ray r(origin, lower_left_corner + u*horizontal + v*vertical);

            vec3 color = ray_color(r, world);

            color.write_color(std::cout);
        }
    }

    std::cerr &lt;&lt; &quot;\nDone.\n&quot;;
}
</code></pre>
<p>Ce qui nous donne l'image suivante qui est une visualisation de où se situe les normales sur la surface de la sphère. C'est souvent une bonne façon pour détecter des problèmes sur un modèle 3D.</p>
<p><img src="img/sphere_normales_sol.png" alt="Rendu d'une sphère avec ses normales colorées et un sol" /></p>
<h1><a class="header" href="#antialiasing" id="antialiasing">Antialiasing</a></h1>
<p>Quand une vraie caméra prend une photo, en général, les bords ne sont pas crenelés car les pixels des bords des objets sont un mélange de premier-plan et d'arrière-plan. Nous poutons obtenir le même effet en faisant la moyenne d'un lot d'échantillons à l'intérieur de chaque pixel. </p>
<p>Une chose dont nous avons besoin est un générateur de nombres aléatoires qui renvoies des nombres réels aléatoires. Nous avons besoin d'une fonction qui renvoie un nombre aléatoire canonique, qui, par convention, renvoie un réel aléatoire dans la plage \(0 \leq r &lt; 1 \). Le 'strictement inférieur' avant le 1 est important car nous en profiterons, comme vous le verrez plus tard.</p>
<p>Une approche simple consiste à utiliser la fonction <code>rand()</code> qui se trouve dans <code>&lt;cstdlib&gt;</code>. Cette fonction renvoie un entier aléatoire compris entre 0 et <code>RAND_MAX</code>. Par conséquent, nous pouvons obtenir un nombre réel aléatoire comme souhaité avec l'extrait de code suivant, ajouté à <code>rtweekend.h</code> :</p>
<pre><code class="language-cpp">#include &lt;cstdlib&gt;
...

inline double random_double() {
    // Returns a random real in [0,1).
    return rand() / (RAND_MAX + 1.0);
}

inline double random_double(double min, double max) {
    // Returns a random real in [min,max).
    return min + (max-min)*random_double();
}
</code></pre>
<p>Le C++ traditionnel n'a pas de générateur de nombre aléatoire standard, seules les versions récentes du C++ ont adressé ce problème par l'en-tête <code>&lt;random&gt;</code> (même si imparfait). Si vous voulez l'utiliser, vous pouvez obtenir un nombre aléatoire respectant les conditions dont nous avons besoin avec ce code :</p>
<pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;random&gt;

inline double random_double() {
    static std::uniform_real_distribution&lt;double&gt; distribution(0.0, 1.0);
    static std::mt19937 generator;
    static std::function&lt;double()&gt; rand_generator =
        std::bind(distribution, generator);
    return rand_generator();
}
</code></pre>
<p>Pour un pixel donné, nous avons plusieurs échantillons à l'intérieur de ce pixel et des rayons traversant chacun de ces échantillons. Les couleurs de ses rayons sont ensuite moyennées :</p>
<p><img src="img/pixel_samples.jpg" alt="Visualisation normales d'une sphère" /></p>
<p>Nous pouvons encapsuler ce nouveau concept dans la classe <code>camera</code> qui reste aligné sur l'axe comme précédemment :</p>
<pre><code class="language-cpp">#ifndef CAMERA_H
#define CAMERA_H

#include &quot;rtweekend.h&quot;

class camera {
    public:
        camera() {
            lower_left_corner = vec3(-2.0, -1.0, -1.0);
            horizontal = vec3(4.0, 0.0, 0.0);
            vertical = vec3(0.0, 2.0, 0.0);
            origin = vec3(0.0, 0.0, 0.0);
        }

        ray get_ray(double u, double v) {
            return ray(origin, lower_left_corner + u*horizontal + v*vertical - origin);
        }

    public:
        vec3 origin;
        vec3 lower_left_corner;
        vec3 horizontal;
        vec3 vertical;
};
#endif
</code></pre>
<p>Pour gérer le multi-échantillonage du calcul de la couleur, nous allons mettre à jour la fonction <code>vec3::write_color()</code>. Plutôt que d'ajouter une petite fraction de la contribution à chaque fois que nous accumulons plus de lumière à la couleur, nous ajoutons simplement la couleur pleine à chaque itération et seulement à la fin, nous divison le résultat par le nombre de samples/échantillons quand nous écrivons la couleur. En plus de ça, nous allons ajouter une fonction pratique à <code>rtweekend.h</code> : <code>clamp(x, min, max)</code> qui borne la valeur \(x \) dans l'intervalle \([min, max] \) :</p>
<pre><code class="language-cpp">inline double clamp(double x, double min, double max) {
    if (x &lt; min) return min;
    if (x &gt; max) return max;
    return x;
}
</code></pre>
<p>vec3.h :</p>
<pre><code class="language-cpp">void write_color(std::ostream &amp;out, int samples_per_pixel) {
    // Divide the color total by the number of samples.
    auto scale = 1.0 / samples_per_pixel;
    auto r = scale * e[0];
    auto g = scale * e[1];
    auto b = scale * e[2];

    // Write the translated [0,255] value of each color component.
    out &lt;&lt; static_cast&lt;int&gt;(256 * clamp(r, 0.0, 0.999)) &lt;&lt; ' '
        &lt;&lt; static_cast&lt;int&gt;(256 * clamp(g, 0.0, 0.999)) &lt;&lt; ' '
        &lt;&lt; static_cast&lt;int&gt;(256 * clamp(b, 0.0, 0.999)) &lt;&lt; '\n';
}
</code></pre>
<p>La fonction <code>main</code> change également :</p>
<pre><code class="language-cpp">int main() {
    const int image_width = 200;
    const int image_height = 100;
    const int samples_per_pixel = 100;

    std::cout &lt;&lt; &quot;P3\n&quot; &lt;&lt; image_width &lt;&lt; &quot; &quot; &lt;&lt; image_height &lt;&lt; &quot;\n255\n&quot;;

    hittable_list world;
    world.add(make_shared&lt;sphere&gt;(vec3(0,0,-1), 0.5));
    world.add(make_shared&lt;sphere&gt;(vec3(0,-100.5,-1), 100));
    camera cam;
    for (int j = image_height-1; j &gt;= 0; --j) {
        std::cerr &lt;&lt; &quot;\rScanlines remaining: &quot; &lt;&lt; j &lt;&lt; ' ' &lt;&lt; std::flush;
        for (int i = 0; i &lt; image_width; ++i) {
            vec3 color(0, 0, 0);
            for (int s = 0; s &lt; samples_per_pixel; ++s) {
                auto u = (i + random_double()) / image_width;
                auto v = (j + random_double()) / image_height;
                ray r = cam.get_ray(u, v);
                color += ray_color(r, world);
            }
            color.write_color(std::cout, samples_per_pixel);
        }
    }

    std::cerr &lt;&lt; &quot;\nDone.\n&quot;;
}
</code></pre>
<p>Maintenant, si nous zoomons sur l'image produite, le grand changement est sur les bords/arêtes qui appartiennent au premier plan et à l'arrière-plan :</p>
<p><img src="img/antialiasing.png" alt="Antialiasing" /></p>
<h1><a class="header" href="#matériaux-diffus" id="matériaux-diffus">Matériaux diffus</a></h1>
<p>Maintenant que nous avons des objets et plusieurs rayons par pixel, nous pouvons passer du temps à la création de matériaux réalistes. Nous allons commencer par des matériaux diffus (mats). Une question est de savoir si l'on peut mélanger les formes et les matériaux (de façon à ce que nous puissons assigner à une sphère un matériau) ou si nous lions fortement la géométrie et les matériaux (utile dans le cas d'objet procéduraux où la forme et les matériaux sont liés). Nous allons choisir la voie de l'assignation séparée - ce qui est habituel pour la plupart des moteurs de rendu - mais soyez au courant de ce choix.</p>
<p>Les objets diffus qui n'émettent pas de lumière ne prennent que très légèrement la couleur de leur environnement, mais ils la modulent avec leur propre couleur intrinsèque. La lumière qui se reflète d'une surface diffuse a une direction aléatoire. Ainsi, si nous lançons des rayons dans une fente entre deux surfaces diffuses, ils auront chacun un comportement aléatoire différent :</p>
<p><img src="img/lumiere_rebonds.jpg" alt="Rayons de lumière qui rebondissent" /></p>
<p>Les rayons peuvent également être absorbés plutôt que reflétés. Plus sombre est la surface, plus l'absorption est probable. (C'est pourquoi il fait sombre!) N'importe quel algorithme qui &quot;randomise&quot; la direction produira une surface qui a une apparence mate. Une des façons les plus simples pour faire ça se révèle en fait idéale pour l'approximation de surface <code>Lambertian</code>. </p>
<p>Il y a deux sphères de rayon unitaire tangentes au point d'impact \(p\) de la surface. Ces deux sphères ont un centre de \((p + \vec{N})\) et \((p - \vec{N})\), où \(\vec{N}\) est la normale de la surface. La sphère qui a un centre à \((p - \vec{N})\) est considérée à <em>l'intérieure</em> de la surface, alors que la sphère de centre \((p + \vec{N})\) est considérée à <em>l'extérieure</em> de la surface. Choisir la sphère de rayon unitaire tangente qui est du même côté de la surface que l'origine du rayon. CHoisir un point aléatoire \(s\) à l'intérieur de la sphère de rayon unitaire et envoyer un rayon du point d'impact \(p\) au point aléatoire \(s\) (c'est le vecteur \((s-p)\)) :</p>
<p><img src="img/rebond_aleatoire_rayon.jpg" alt="Rebon aléatoire de rayon" /></p>
<p>Nous avons besoin d'un moyen de générer un point aléatoire dans une sphère de rayon unitaire. Nous allons utiliser l'algorithme le plus simple : la méthode par rejet. En premier, il faut générer un point aléatoire dans un cube de dimension unitaire où x, y et z sont dans l'intervalle -1 à +1. Rejeter le point et re-essayer si le point est en dehors de la sphère.</p>
<p>On ajoute des méthodes pour générer un <code>vec3</code> aléatoire :</p>
<pre><code class="language-cpp">class vec3 {
  public:
    ...
    inline static vec3 random() {
        return vec3(random_double(), random_double(), random_double());
    }

    inline static vec3 random(double min, double max) {
        return vec3(random_double(min,max), random_double(min,max), random_double(min,max));
    }
</code></pre>
<p>La fonction <code>random_in_unit_sphere()</code> :</p>
<pre><code class="language-cpp">vec3 random_in_unit_sphere() {
    while (true) {
        auto p = vec3::random(-1,1);
        if (p.length_squared() &gt;= 1) continue;
        return p;
    }
}
</code></pre>
<p>Ensuite, mettez à jour la fonction <code>ray_color()</code> pour utiliser le générateur de direction aléatoire :</p>
<pre><code class="language-cpp">vec3 ray_color(const ray&amp; r, const hittable&amp; world) {
    hit_record rec;

    if (world.hit(r, 0, infinity, rec)) {
        vec3 target = rec.p + rec.normal + random_in_unit_sphere();
        return 0.5 * ray_color(ray(rec.p, target - rec.p), world);
    }

    vec3 unit_direction = unit_vector(r.direction());
    auto t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);
}
</code></pre>
<p>Il y a un problème potentiel avec cette implémentation. Notez que la fonction <code>ray_color</code> est récursive. Quand sa récursion s'arrêtera ? Quand la fonction échouera de <code>hit</code> quelque chose. Dans certains cas, ça peut être très lent - assez longtemps pour exploser le <em>stack</em>. Pour se protéger contre ça, limitons la profondeur de recursion maximale, retournant aucune contribution de lumière à la profondeur maximale :</p>
<pre><code class="language-cpp">vec3 ray_color(const ray&amp; r, const hittable&amp; world, int depth) {
    hit_record rec;

    // If we've exceeded the ray bounce limit, no more light is gathered.
    if (depth &lt;= 0)
        return vec3(0,0,0);

    if (world.hit(r, 0, infinity, rec)) {
        vec3 target = rec.p + rec.normal + random_in_unit_sphere();
        return 0.5 * ray_color(ray(rec.p, target - rec.p), world, depth-1);
    }

    vec3 unit_direction = unit_vector(r.direction());
    auto t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);
}
...
int main() {
    const int image_width = 200;
    const int image_height = 100;
    const int samples_per_pixel = 100;
    const int max_depth = 50;

    ...
    for (int j = image_height-1; j &gt;= 0; --j) {
        std::cerr &lt;&lt; &quot;\rScanlines remaining: &quot; &lt;&lt; j &lt;&lt; ' ' &lt;&lt; std::flush;
        for (int i = 0; i &lt; image_width; ++i) {
            vec3 color(0, 0, 0);
            for (int s = 0; s &lt; samples_per_pixel; ++s) {
                auto u = (i + random_double()) / image_width;
                auto v = (j + random_double()) / image_height;
                ray r = cam.get_ray(u, v);
                color += ray_color(r, world, max_depth);
            }
            color.write_color(std::cout, samples_per_pixel);
        }
    }

    std::cerr &lt;&lt; &quot;\nDone.\n&quot;;
}
</code></pre>
<p>Ce qui nous donne l'image :
<img src="img/premier_rendu_materiau_diffus.jpg" alt="Premier rendu d'une sphère diffuse" /></p>
<p>Notez l'ombre sous la sphère. L'image est très sombre, mais nos sphères n'absorbent que la moitié de l'énergie à chaque rebond, elles sont donc réflectives à 50%. Si vous ne voyez pas l'ombre, ne vous inquiètez pas, nous allons y remédier maintenant. Ces sphères doivent être assez lumineuses en réalité (gris clair). La raison à cela est que la plupart des lecteurs d'image assume que l'image est &quot;gamma corrigé&quot;. Ce qui veut dire que les valeurs de 0 à 1 ont une transformation appliquée avant d'être enregistré. Il y a plusieurs bonnes raisons à cela, mais pour notre but, nous avons juste besoin de savoir ça. Pour une première approximation, nous pouvons utiliser &quot;gamma 2&quot; ce qui signifie mettre la couleur à la puissance <em>1/gamma</em>, ou dans cas, 1/2, ce qui correspond à la racine-carrée :</p>
<p>La fonction <code>write_color()</code> avec correction du gamma :</p>
<pre><code class="language-cpp">void write_color(std::ostream &amp;out, int samples_per_pixel) {
    // Divide the color total by the number of samples and gamma-correct
    // for a gamma value of 2.0.
    auto scale = 1.0 / samples_per_pixel;
    auto r = sqrt(scale * e[0]);
    auto g = sqrt(scale * e[1]);
    auto b = sqrt(scale * e[2]);

    // Write the translated [0,255] value of each color component.
    out &lt;&lt; static_cast&lt;int&gt;(256 * clamp(r, 0.0, 0.999)) &lt;&lt; ' '
        &lt;&lt; static_cast&lt;int&gt;(256 * clamp(g, 0.0, 0.999)) &lt;&lt; ' '
        &lt;&lt; static_cast&lt;int&gt;(256 * clamp(b, 0.0, 0.999)) &lt;&lt; '\n';
}
</code></pre>
<p>Ce qui nous donne une sphère grise claire, comme nous le désirions :</p>
<p><img src="img/sphere_gamma_corrige.jpg" alt="Sphère diffuse avec correction du gamma" /></p>
<h1><a class="header" href="#métal" id="métal">Métal</a></h1>
<h1><a class="header" href="#diélectrique" id="diélectrique">Diélectrique</a></h1>
<h1><a class="header" href="#caméra-positionnable" id="caméra-positionnable">Caméra positionnable</a></h1>
<h1><a class="header" href="#flou-de-focus" id="flou-de-focus">Flou de focus</a></h1>
<p>Développons à présent notre fonctionnalité finale : le flou de focus. Notez que tous les photographes l'appellent &quot;flou de profondeur&quot; donc préférez le terme &quot;flou de focus&quot; (<em>defocus blur</em>) avec vos amis.</p>
<p>La raison pour laquelle le flou de focus existe sur de vrais appareils photos est parce qu'ils ont besoin d'un grand trou (plutôt qu'un petit point) pour obtenir de la lumière. Ca rendra tout flou, mais si on insère une lentille dans ce trou, il y aura une certaine distance où tout sera en focus. VOus pouvez imaginer une lentille de la sorte : tous les rayons lumineux venant d'un point spécique à la distance focale - et qui touche la lentille - sera recourbé vers un seul point sur le capteur d'image.</p>
<p>Sur un appareil photo physique, la distance au plan à partir duquel les choses sont en focus est controllé par la distance entre la lentille et la pellicule/capteur. C'est pour cette raison que l'on voit la lentille se déplacer relativement vers la caméra quand on change ce qui est en focus (ce phénomèneme apparait sur votre smartphone également, mais c'est le capteur qui bouge dans ce cas). L'ouverture (<em>aperture</em>) est un trou qui controle le taille effective de la lentille. Pour un vrai appareil photo, si vous avez besoin de plus de lumière, vous pouvez agrandir l'ouverture, et par la même occasion vous obtiendrez plus de flou de focus. Pour notre caméra virtuelle, nous pouvons avoir un capteur parfait et ne jamais avoir besoin de plus de lumière, donc seulement quand nous voudrons un flou de focus nous utiliserons le principe de l'ouverture/<em>aperture</em>.</p>
<p>Un vrai appareil photo a une lentille composée complexe. Dans notre code, nous allons simuler l'ordre : capteur, ensuite lentille, puis ouverture, et déduire où envoyer les rayons puis renverser (<em>flip</em>) l'image une fois calculée (l'image est projetée à l'envers sur la pellicule). En général, nous utilisons le modèle d'approximation d'une lentille fine :</p>
<p><img src="img/modele_lentille.jpg" alt="Modèle de lentille d'appareil photo" /></p>
<p>Nous n'avons pas besoin de simuler l'intérieur de l'appareil photo. Pour notre besoin de faire le rendu d'une image à l'extérieur de la caméra, ça serait une complexité non nécessaire. A la place, je fais commencer les rayons de la surface de la lentille et je les envoie vers une pellicule virtuelle plane, en trouvant la projection de la pellicule sur le plan qui est en focus (à la distance que nous noterons <code>focus_dist</code>).</p>
<p><img src="img/plan_focus.jpg" alt="Plan de focus de la caméra" /></p>
<p>Normalement, tous les rayons de la scène ont comme origine le point <code>lookfrom</code>. Afin de réaliser un flou de focus, nous générons des rayons aléatoires qui commencent à l'intérieur d'un disque centré sur le point <code>lookfrom</code>. Plus grand est le rayon de ce disque, plus grand sera le flou de focus. Vous pouvez imaginer que notre caméra de départ avait le rayon de ce disque de defocus égal à zéro (donc aucun flou). De cette manière, tous les rayons étaient lancés à partir du centre du disque (<code>lookfrom</code>).</p>
<p>Générons des points aléatoires à l'intérieur d'un disque de rayon unitaire :</p>
<pre><code class="language-cpp">vec3 random_in_unit_disk() {
    while (true) {
        auto p = vec3(random_double(-1,1), random_double(-1,1), 0);
        if (p.length_squared() &gt;= 1) continue;
        return p;
    }
}
</code></pre>
<p>Changeons la définition de notre classe <code>camera</code> un peu pour qu'elle puisse avoir une profondeur de champs ajustable (<em>depth-of-field</em> ou <em>dof</em>) : </p>
<pre><code class="language-cpp">class camera {
    public:
        camera(
            vec3 lookfrom, vec3 lookat, vec3 vup,
            double vfov, // top to bottom, in degrees
            double aspect, double aperture, double focus_dist
        ) {
            origin = lookfrom;
            lens_radius = aperture / 2;

            auto theta = degrees_to_radians(vfov);
            auto half_height = tan(theta/2);
            auto half_width = aspect * half_height;

            w = unit_vector(lookfrom - lookat);
            u = unit_vector(cross(vup, w));
            v = cross(w, u);
            lower_left_corner = origin
                              - half_width * focus_dist * u
                              - half_height * focus_dist * v
                              - focus_dist * w;

            horizontal = 2*half_width*focus_dist*u;
            vertical = 2*half_height*focus_dist*v;
        }

        ray get_ray(double s, double t) {
            vec3 rd = lens_radius * random_in_unit_disk();
            vec3 offset = u * rd.x() + v * rd.y();

            return ray(
                origin + offset,
                lower_left_corner + s*horizontal + t*vertical - origin - offset
            );
        }

    public:
        vec3 origin;
        vec3 lower_left_corner;
        vec3 horizontal;
        vec3 vertical;
        vec3 u, v, w;
        double lens_radius;
};
</code></pre>
<p>En utilisant une grande ouverture/<em>aperture</em> :</p>
<pre><code class="language-cpp">const auto aspect_ratio = double(image_width) / image_height;
...
vec3 lookfrom(3,3,2);
vec3 lookat(0,0,-1);
vec3 vup(0,1,0);
auto dist_to_focus = (lookfrom-lookat).length();
auto aperture = 2.0;

camera cam(lookfrom, lookat, vup, 20, aspect_ratio, aperture, dist_to_focus);
</code></pre>
<p>Nous obtenons le résultat :
<img src="img/profondeur_de_champs.png" alt="Sphères avec profondeur de champs" /></p>
<h1><a class="header" href="#que-faire-ensuite" id="que-faire-ensuite">Que faire-ensuite</a></h1>
<p>Déjà, nous allons recréer l'image de la couverture de ce livre : plein de sphères aléatoires :</p>
<pre><code class="language-cpp">hittable_list random_scene() {
    hittable_list world;

    world.add(make_shared&lt;sphere&gt;(
        vec3(0,-1000,0), 1000, make_shared&lt;lambertian&gt;(vec3(0.5, 0.5, 0.5))));

    int i = 1;
    for (int a = -11; a &lt; 11; a++) {
        for (int b = -11; b &lt; 11; b++) {
            auto choose_mat = random_double();
            vec3 center(a + 0.9*random_double(), 0.2, b + 0.9*random_double());
            if ((center - vec3(4, 0.2, 0)).length() &gt; 0.9) {
                if (choose_mat &lt; 0.8) {
                    // diffuse
                    auto albedo = vec3::random() * vec3::random();
                    world.add(
                        make_shared&lt;sphere&gt;(center, 0.2, make_shared&lt;lambertian&gt;(albedo)));
                } else if (choose_mat &lt; 0.95) {
                    // metal
                    auto albedo = vec3::random(.5, 1);
                    auto fuzz = random_double(0, .5);
                    world.add(
                        make_shared&lt;sphere&gt;(center, 0.2, make_shared&lt;metal&gt;(albedo, fuzz)));
                } else {
                    // glass
                    world.add(make_shared&lt;sphere&gt;(center, 0.2, make_shared&lt;dielectric&gt;(1.5)));
                }
            }
        }
    }

    world.add(make_shared&lt;sphere&gt;(vec3(0, 1, 0), 1.0, make_shared&lt;dielectric&gt;(1.5)));

    world.add(
        make_shared&lt;sphere&gt;(vec3(-4, 1, 0), 1.0, make_shared&lt;lambertian&gt;(vec3(0.4, 0.2, 0.1))));

    world.add(
        make_shared&lt;sphere&gt;(vec3(4, 1, 0), 1.0, make_shared&lt;metal&gt;(vec3(0.7, 0.6, 0.5), 0.0)));

    return world;
}

int main() {
    ...
    auto world = random_scene();

    vec3 lookfrom(13,2,3);
    vec3 lookat(0,0,0);
    vec3 vup(0,1,0);
    auto dist_to_focus = 10.0;
    auto aperture = 0.1;

    camera cam(lookfrom, lookat, vup, 20, aspect_ratio, aperture, dist_to_focus);
    ...
}
</code></pre>
<p>Ce qui nous donne la scène finale suivante :</p>
<p><img src="img/scene_finale.jpg" alt="Scène finale" /></p>
<p>Un point intéressant à noter est que les sphères en verre n'ont apparemment pas d'ombre, ce qui donne l'impression qu'elles flottent dans l'air. Ce n'est pas un bug (vous ne voyez pas de sphères de verre souvent dans la réalité, elles apparaissent pourtant de cette façon, sans ombre, notamment les jours nuageux). Un point sur la grande sphère sous une sphère de verre reçoit pourtant beaucoup de lumière.  C'est dû au fait que le ciel est ré-arrangé plutôt que bloqué.</p>
<p>Vous avez maintenant un ray tracer cool ! Que faire-ensuite ?</p>
<ol>
<li>
<p>Les lumières. Vous pouvez le faire explicitement, en envoyant des rayons d'ombre aux lumières. Ou ça peut être fait implicitement en faisant en sorte que des objets puissent émettre de la lumière.</p>
</li>
<li>
<p>La polarisation a dispersé les rayons vers eux, puis la sous-pondération de ces rayons pour annuler le biais. Les deux fonctionnent. Je préfère cette dernière approche même si elle ne fait pas l'hunanimité.</p>
</li>
<li>
<p>Les triangles. Les modèles chouettes sont composés de triangles. Le modèle d'I/O est le plus dur, et chacun essaye de copier le code de quelqu'un d'autre pour faire ça.</p>
</li>
<li>
<p>Les textures de surface. Ca vous permet de coller des images sur vos modèles comme du papier-peint. Assez facile et un bon ajout à notre ray tracer.</p>
</li>
<li>
<p>Des textures solides. Ken Perlin a son code en ligne. Andrew Kensler a pas mals d'informations intéressantes à ce sujet sur son blog.</p>
</li>
<li>
<p>Gestion des volumes et media. Quelque chose de sympa et qui challengera votre architecture logicielle. Ma solution est de faire un volume qui a une interface <code>hittable</code> et de façon probabilistique, a ses intersections basées sur sa densité. Votre code de rendu n'a pas à savoir qu'il a des volumes avec cette méthode.</p>
</li>
<li>
<p>Parallélisme. Lancer \(N\) copies de votre code sur \(N\) coeurs avec differentes graines aléatoires (<em>random seeds</em>). Moyenner les \(N\) lancements. La moyenne peut aussi se faire hierarchiquement où \(N/2\) paires pour obtenir \(N/4\) images, et ces paires peuvent ensuite être moyennées. Cette méthode de parallélisation devrait s'étendre bien à des machines équipées de milliers de coeurs et avec très peu de code.</p>
</li>
</ol>
<p>Amusez-vous et envoyez-moi vos images sympas !</p>
<h1><a class="header" href="#remerciements" id="remerciements">Remerciements</a></h1>
<h2><a class="header" href="#aide-sur-le-manuscrit-dorigine" id="aide-sur-le-manuscrit-dorigine">Aide sur le manuscrit d'origine</a></h2>
<ul>
<li>Dave Hart</li>
<li>Jean Buckley</li>
</ul>
<h2><a class="header" href="#version-web" id="version-web">Version Web</a></h2>
<ul>
<li>Berna Kabadayı</li>
<li>Lorenzo Mancini</li>
<li>Lori Whippler Hollasch</li>
<li>Ronald Wotzlaw</li>
</ul>
<h2><a class="header" href="#corrections-et-améliorations" id="corrections-et-améliorations">Corrections et Améliorations</a></h2>
<ul>
<li>Aaryaman Vasishta</li>
<li>Andrew Kensler</li>
<li>Apoorva Joshi</li>
<li>Aras Pranckevičius</li>
<li>Becker</li>
<li>Ben Kerl</li>
<li>Benjamin Summerton</li>
<li>Bennett Hardwick</li>
<li>Dan Drummond</li>
<li>David Chambers</li>
<li>David Hart</li>
<li>Eric Haines</li>
<li>Fabio Sancinetti</li>
<li>Filipe Scur</li>
<li>Frank He</li>
<li>Gerrit Wessendorf</li>
<li>Grue Debry</li>
<li>Ingo Wald</li>
<li>Jason Stone</li>
<li>Jean Buckley</li>
<li>Joey Cho</li>
<li>Lorenzo Mancini</li>
<li>Marcus Ottosson</li>
<li>Matthew Heimlich</li>
<li>Nakata Daisuke</li>
<li>Paul Melis</li>
<li>Phil Cristensen</li>
<li>Ronald Wotzlaw</li>
<li>Tatsuya Ogawa</li>
<li>Thiago Ize</li>
<li>Vahan Sosoyan</li>
</ul>
<h2><a class="header" href="#outils" id="outils">Outils</a></h2>
<p>Merci à l'équipe de <a href="https://limnu.com/">Limnu</a> pour son aide sur les schémas.
Immense remerciement pour Morgan McGuire pour sa fantastique librairie <a href="https://casual-effects.com/markdeep/">Markdeep</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
