<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Matériaux diffus - Raytracing en un weekend</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="creer_une_image.html"><strong aria-hidden="true">1.</strong> Créer une image</a></li><li class="chapter-item expanded "><a href="la_classe_vec3.html"><strong aria-hidden="true">2.</strong> La classe vec3</a></li><li class="chapter-item expanded "><a href="rayons_camera_arriere_plan.html"><strong aria-hidden="true">3.</strong> Des rayons, une caméra et un arrière-plan</a></li><li class="chapter-item expanded "><a href="ajouter_une_sphere.html"><strong aria-hidden="true">4.</strong> Ajouter une sphère</a></li><li class="chapter-item expanded "><a href="normale_surface_plusieurs_objets.html"><strong aria-hidden="true">5.</strong> Normale à une surface et plusieurs objets</a></li><li class="chapter-item expanded "><a href="antialiasing.html"><strong aria-hidden="true">6.</strong> Antialiasing</a></li><li class="chapter-item expanded "><a href="materiaux_diffus.html" class="active"><strong aria-hidden="true">7.</strong> Matériaux diffus</a></li><li class="chapter-item expanded "><a href="metal.html"><strong aria-hidden="true">8.</strong> Métal</a></li><li class="chapter-item expanded "><a href="dielectrique.html"><strong aria-hidden="true">9.</strong> Diélectrique</a></li><li class="chapter-item expanded "><a href="camera_positionnable.html"><strong aria-hidden="true">10.</strong> Caméra positionnable</a></li><li class="chapter-item expanded "><a href="flou_de_focus.html"><strong aria-hidden="true">11.</strong> Flou de focus</a></li><li class="chapter-item expanded "><a href="que_faire_ensuite.html"><strong aria-hidden="true">12.</strong> Que faire-ensuite</a></li><li class="chapter-item expanded "><a href="remerciements.html"><strong aria-hidden="true">13.</strong> Remerciements</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Raytracing en un weekend</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#matériaux-diffus" id="matériaux-diffus">Matériaux diffus</a></h1>
<p>Maintenant que nous avons des objets et plusieurs rayons par pixel, nous pouvons passer du temps à la création de matériaux réalistes. Nous allons commencer par des matériaux diffus (mats). Une question est de savoir si l'on peut mélanger les formes et les matériaux (de façon à ce que nous puissons assigner à une sphère un matériau) ou si nous lions fortement la géométrie et les matériaux (utile dans le cas d'objet procéduraux où la forme et les matériaux sont liés). Nous allons choisir la voie de l'assignation séparée - ce qui est habituel pour la plupart des moteurs de rendu - mais soyez au courant de ce choix.</p>
<p>Les objets diffus qui n'émettent pas de lumière ne prennent que très légèrement la couleur de leur environnement, mais ils la modulent avec leur propre couleur intrinsèque. La lumière qui se reflète d'une surface diffuse a une direction aléatoire. Ainsi, si nous lançons des rayons dans une fente entre deux surfaces diffuses, ils auront chacun un comportement aléatoire différent :</p>
<p><img src="img/lumiere_rebonds.jpg" alt="Rayons de lumière qui rebondissent" /></p>
<p>Les rayons peuvent également être absorbés plutôt que reflétés. Plus sombre est la surface, plus l'absorption est probable. (C'est pourquoi il fait sombre!) N'importe quel algorithme qui &quot;randomise&quot; la direction produira une surface qui a une apparence mate. Une des façons les plus simples pour faire ça se révèle en fait idéale pour l'approximation de surface <code>Lambertian</code>. </p>
<p>Il y a deux sphères de rayon unitaire tangentes au point d'impact \(p\) de la surface. Ces deux sphères ont un centre de \((p + \vec{N})\) et \((p - \vec{N})\), où \(\vec{N}\) est la normale de la surface. La sphère qui a un centre à \((p - \vec{N})\) est considérée à <em>l'intérieure</em> de la surface, alors que la sphère de centre \((p + \vec{N})\) est considérée à <em>l'extérieure</em> de la surface. Choisir la sphère de rayon unitaire tangente qui est du même côté de la surface que l'origine du rayon. CHoisir un point aléatoire \(s\) à l'intérieur de la sphère de rayon unitaire et envoyer un rayon du point d'impact \(p\) au point aléatoire \(s\) (c'est le vecteur \((s-p)\)) :</p>
<p><img src="img/rebond_aleatoire_rayon.jpg" alt="Rebon aléatoire de rayon" /></p>
<p>Nous avons besoin d'un moyen de générer un point aléatoire dans une sphère de rayon unitaire. Nous allons utiliser l'algorithme le plus simple : la méthode par rejet. En premier, il faut générer un point aléatoire dans un cube de dimension unitaire où x, y et z sont dans l'intervalle -1 à +1. Rejeter le point et re-essayer si le point est en dehors de la sphère.</p>
<p>On ajoute des méthodes pour générer un <code>vec3</code> aléatoire :</p>
<pre><code class="language-cpp">class vec3 {
  public:
    ...
    inline static vec3 random() {
        return vec3(random_double(), random_double(), random_double());
    }

    inline static vec3 random(double min, double max) {
        return vec3(random_double(min,max), random_double(min,max), random_double(min,max));
    }
</code></pre>
<p>La fonction <code>random_in_unit_sphere()</code> :</p>
<pre><code class="language-cpp">vec3 random_in_unit_sphere() {
    while (true) {
        auto p = vec3::random(-1,1);
        if (p.length_squared() &gt;= 1) continue;
        return p;
    }
}
</code></pre>
<p>Ensuite, mettez à jour la fonction <code>ray_color()</code> pour utiliser le générateur de direction aléatoire :</p>
<pre><code class="language-cpp">vec3 ray_color(const ray&amp; r, const hittable&amp; world) {
    hit_record rec;

    if (world.hit(r, 0, infinity, rec)) {
        vec3 target = rec.p + rec.normal + random_in_unit_sphere();
        return 0.5 * ray_color(ray(rec.p, target - rec.p), world);
    }

    vec3 unit_direction = unit_vector(r.direction());
    auto t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);
}
</code></pre>
<p>Il y a un problème potentiel avec cette implémentation. Notez que la fonction <code>ray_color</code> est récursive. Quand sa récursion s'arrêtera ? Quand la fonction échouera de <code>hit</code> quelque chose. Dans certains cas, ça peut être très lent - assez longtemps pour exploser le <em>stack</em>. Pour se protéger contre ça, limitons la profondeur de recursion maximale, retournant aucune contribution de lumière à la profondeur maximale :</p>
<pre><code class="language-cpp">vec3 ray_color(const ray&amp; r, const hittable&amp; world, int depth) {
    hit_record rec;

    // If we've exceeded the ray bounce limit, no more light is gathered.
    if (depth &lt;= 0)
        return vec3(0,0,0);

    if (world.hit(r, 0, infinity, rec)) {
        vec3 target = rec.p + rec.normal + random_in_unit_sphere();
        return 0.5 * ray_color(ray(rec.p, target - rec.p), world, depth-1);
    }

    vec3 unit_direction = unit_vector(r.direction());
    auto t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);
}
...
int main() {
    const int image_width = 200;
    const int image_height = 100;
    const int samples_per_pixel = 100;
    const int max_depth = 50;

    ...
    for (int j = image_height-1; j &gt;= 0; --j) {
        std::cerr &lt;&lt; &quot;\rScanlines remaining: &quot; &lt;&lt; j &lt;&lt; ' ' &lt;&lt; std::flush;
        for (int i = 0; i &lt; image_width; ++i) {
            vec3 color(0, 0, 0);
            for (int s = 0; s &lt; samples_per_pixel; ++s) {
                auto u = (i + random_double()) / image_width;
                auto v = (j + random_double()) / image_height;
                ray r = cam.get_ray(u, v);
                color += ray_color(r, world, max_depth);
            }
            color.write_color(std::cout, samples_per_pixel);
        }
    }

    std::cerr &lt;&lt; &quot;\nDone.\n&quot;;
}
</code></pre>
<p>Ce qui nous donne l'image :
<img src="img/premier_rendu_materiau_diffus.jpg" alt="Premier rendu d'une sphère diffuse" /></p>
<p>Notez l'ombre sous la sphère. L'image est très sombre, mais nos sphères n'absorbent que la moitié de l'énergie à chaque rebond, elles sont donc réflectives à 50%. Si vous ne voyez pas l'ombre, ne vous inquiètez pas, nous allons y remédier maintenant. Ces sphères doivent être assez lumineuses en réalité (gris clair). La raison à cela est que la plupart des lecteurs d'image assume que l'image est &quot;gamma corrigé&quot;. Ce qui veut dire que les valeurs de 0 à 1 ont une transformation appliquée avant d'être enregistré. Il y a plusieurs bonnes raisons à cela, mais pour notre but, nous avons juste besoin de savoir ça. Pour une première approximation, nous pouvons utiliser &quot;gamma 2&quot; ce qui signifie mettre la couleur à la puissance <em>1/gamma</em>, ou dans cas, 1/2, ce qui correspond à la racine-carrée :</p>
<p>La fonction <code>write_color()</code> avec correction du gamma :</p>
<pre><code class="language-cpp">void write_color(std::ostream &amp;out, int samples_per_pixel) {
    // Divide the color total by the number of samples and gamma-correct
    // for a gamma value of 2.0.
    auto scale = 1.0 / samples_per_pixel;
    auto r = sqrt(scale * e[0]);
    auto g = sqrt(scale * e[1]);
    auto b = sqrt(scale * e[2]);

    // Write the translated [0,255] value of each color component.
    out &lt;&lt; static_cast&lt;int&gt;(256 * clamp(r, 0.0, 0.999)) &lt;&lt; ' '
        &lt;&lt; static_cast&lt;int&gt;(256 * clamp(g, 0.0, 0.999)) &lt;&lt; ' '
        &lt;&lt; static_cast&lt;int&gt;(256 * clamp(b, 0.0, 0.999)) &lt;&lt; '\n';
}
</code></pre>
<p>Ce qui nous donne une sphère grise claire, comme nous le désirions :</p>
<p><img src="img/sphere_gamma_corrige.jpg" alt="Sphère diffuse avec correction du gamma" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="antialiasing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="metal.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="antialiasing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="metal.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
