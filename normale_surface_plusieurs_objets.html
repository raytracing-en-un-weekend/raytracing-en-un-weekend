<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Normale à une surface et plusieurs objets - Raytracing en un weekend</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="creer_une_image.html"><strong aria-hidden="true">1.</strong> Créer une image</a></li><li class="chapter-item expanded "><a href="la_classe_vec3.html"><strong aria-hidden="true">2.</strong> La classe vec3</a></li><li class="chapter-item expanded "><a href="rayons_camera_arriere_plan.html"><strong aria-hidden="true">3.</strong> Des rayons, une caméra et un arrière-plan</a></li><li class="chapter-item expanded "><a href="ajouter_une_sphere.html"><strong aria-hidden="true">4.</strong> Ajouter une sphère</a></li><li class="chapter-item expanded "><a href="normale_surface_plusieurs_objets.html" class="active"><strong aria-hidden="true">5.</strong> Normale à une surface et plusieurs objets</a></li><li class="chapter-item expanded "><a href="antialiasing.html"><strong aria-hidden="true">6.</strong> Antialiasing</a></li><li class="chapter-item expanded "><a href="materiaux_diffus.html"><strong aria-hidden="true">7.</strong> Matériaux diffus</a></li><li class="chapter-item expanded "><a href="metal.html"><strong aria-hidden="true">8.</strong> Métal</a></li><li class="chapter-item expanded "><a href="dielectrique.html"><strong aria-hidden="true">9.</strong> Diélectrique</a></li><li class="chapter-item expanded "><a href="camera_positionnable.html"><strong aria-hidden="true">10.</strong> Caméra positionnable</a></li><li class="chapter-item expanded "><a href="flou_de_focus.html"><strong aria-hidden="true">11.</strong> Flou de focus</a></li><li class="chapter-item expanded "><a href="que_faire_ensuite.html"><strong aria-hidden="true">12.</strong> Que faire-ensuite</a></li><li class="chapter-item expanded "><a href="remerciements.html"><strong aria-hidden="true">13.</strong> Remerciements</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Raytracing en un weekend</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#normale-à-une-surface-et-plusieurs-objets" id="normale-à-une-surface-et-plusieurs-objets">Normale à une surface et plusieurs objets</a></h1>
<p>Premièrement, définissons ce qu'est une normale, puis utilisons ce concept pour nuancer/ombrager les objets.
Une normale est un vecteur qui est perpendiculaire à la surface au point d'intersection. Il y a deux façons de concevoir des normales.
La première est de faire une normale à partir d'un vecteur de longueur unitaire. C'est pratique pour nuancer/ombrager donc je dirai que c'est une bonne solution, mais comme dit précédemment, je ne vais pas le faire dans le code. Ca peut entrainer des bugs difficiles à débusquer.</p>
<p>Pour une sphère, la normale extérieure est dans la direction du point d'impact, auquel on aurait soustrait la position du centre :</p>
<p><img src="img/normale_sphere.jpg" alt="Normale à une sphère" /></p>
<p>Si on prend la terre pour exemple, ça implique donc que le vecteur qui part du centre de la terre au point jusqu'à vous pointe vers le haut.</p>
<p>Implémentons ça et voyons le résultat.</p>
<p>Pour l'instant, nous n'avons aucune lumière donc nous allons devoir visualiser les normales en utilisant un jeu de couleurs. 
Une astuce utilisée fréquemment pour la visualisation de normales (car facile et intuitif d'assumer que \(N\) est un vecteur de longueur unitaire, donc chacun de ses composants est entre -1 et 1) est d'associer à chaque composant de l'intervalle 0 à 1, la valeur x/y/z en r/g/b. 
Pour une normale, nous avons besoin du point d'intersection, pas seulement savoir si le rayon a touché ou non la sphère. Nous allons assumer que la normale est désignée par le point d'intersection le plus proche (le plus petit \(t\) possible).</p>
<p>Notre code modifié qui nous permet de calculer et visualiser \(N\) est le suivant :</p>
<pre><code class="language-cpp">double hit_sphere(const vec3&amp; center, double radius, const ray&amp; r) {
    vec3 oc = r.origin() - center;
    auto a = dot(r.direction(), r.direction());
    auto b = 2.0 * dot(oc, r.direction());
    auto c = dot(oc, oc) - radius*radius;
    auto discriminant = b*b - 4*a*c;
    if (discriminant &lt; 0) {
        return -1.0;
    } else {
        return (-b - sqrt(discriminant) ) / (2.0*a);
    }
}

vec3 ray_color(const ray&amp; r) {
    auto t = hit_sphere(vec3(0,0,-1), 0.5, r);
    if (t &gt; 0.0) {
        vec3 N = unit_vector(r.at(t) - vec3(0,0,-1));
        return 0.5*vec3(N.x()+1, N.y()+1, N.z()+1);
    }
    vec3 unit_direction = unit_vector(r.direction());
    t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);
}
</code></pre>
<p>Ce qui nous donne l'image suivante :</p>
<p><img src="img/visualisation_normales_sphere.png" alt="Visualisation normales d'une sphère" /></p>
<p>Chaque pixel de la sphère est coloré selon son vecteur normal. </p>
<p>Revisitons l'équation de l'intersection d'un rayon et d'une sphère, précédemment nous avions :</p>
<pre><code class="language-cpp">vec3 oc = r.origin() - center;
auto a = dot(r.direction(), r.direction());
auto b = 2.0 * dot(oc, r.direction());
auto c = dot(oc, oc) - radius*radius;
auto discriminant = b*b - 4*a*c;
</code></pre>
<p>Déjà, souvenez-vous qu'un vecteur dont on fait le produit scalaire (<em>dot product</em>) avec lui-même est égal au carré de la longueur de ce vecteur.
Deuxièmement, notez comment l'équation suivante a un facteur 2 pour \(b\). Observez ce qu'il se passe à l'équation quadratique si \(b=2h\) :</p>
<p>\[ -b \pm \sqrt{b^2 - 4ac} \over{2a}\]</p>
<p>\[ = \frac{-2h \pm \sqrt{(2h)^2 - 4ac}}{2a}\]</p>
<p>\[ = \frac{-2h \pm 2\sqrt{h^2 - ac}}{2a}\]</p>
<p>\[ = \frac{-h \pm \sqrt{h^2 - ac}}{a}\]</p>
<p>En utilisant ces observations, nous pouvons simplifier le code par ça :</p>
<pre><code class="language-cpp">vec3 oc = r.origin() - center;
auto a = r.direction().length_squared();
auto half_b = dot(oc, r.direction());
auto c = oc.length_squared() - radius*radius;
auto discriminant = half_b*half_b - a*c;

if (discriminant &lt; 0) {
    return -1.0;
} else {
    return (-half_b - sqrt(discriminant) ) / a;
}
</code></pre>
<p>Maintenant, comment gérer plusieurs sphères ? Il serait assez tentant de stocker un tableau de sphères, une solution très propre serait d'avoir une classe abtraite (que l'on ne peut pas instancier) pour chaque objet qu'un rayon pourrait traverser. De cette manière, une sphère, ou une liste de sphères pourraient être traversées. Le nom à donner à cette classe est un vrai dilemme : si on l'appelle objet ce n'est pas un bon nom puisqu'on fait de la programmation orientée objet par exemple. &quot;Surface&quot; est souvent utilisé, sauf que parfois nous voulons gérer des volumes... &quot;hittable&quot; (de l'anglais 'hit', touché, 'hittable', que l'on peut toucher) met en avant la principale fonction membre : 'hit'. Je n'aime aucun de ces choix mais partons sur 'hittable'.</p>
<p>Cette classe <em>hittable</em> aura donc une méthode qui prend en paramètre un rayon (<em>ray</em>). La plupart des raytracers a jugé bon d'ajouter un intervalle valide pour la valeur \(t\) pour que \(t\) soit compris entre \(t_{min}\) et \(t_{max}\). Si \(t\) ne respecte pas \(t_{min} &lt; t &lt; t_{max}\), le &quot;hit&quot; n'est pas détecté. Une question qui apparait maintenant est : doit-on calculer la normale si le rayon touche quelque chose ? On pourrait finir par toucher quelque chose de plus proche et du coup, nous n'aurions besoin que de la normale de l'objet le plus proche. Je vais partir sur la solution simple et calculer un lot de petites choses que je stockerai dans une structure.</p>
<p>Voici la classe abstraite 'hittable' :</p>
<pre><code class="language-cpp">#ifndef HITTABLE_H
#define HITTABLE_H

#include &quot;ray.h&quot;

struct hit_record {
    vec3 p;
    vec3 normal;
};

class hittable {
    public:
        virtual bool hit(const ray&amp; r, double t_min, double t_max, hit_record&amp; rec) const = 0;
};

#endif
</code></pre>
<p>Et voici l'implémentation pour la sphère :</p>
<pre><code class="language-cpp">#ifndef SPHERE_H
#define SPHERE_H

#include &quot;hittable.h&quot;
#include &quot;vec3.h&quot;

class sphere: public hittable {
    public:
        sphere() {}
        sphere(vec3 cen, double r) : center(cen), radius(r) {};

        virtual bool hit(const ray&amp; r, double tmin, double tmax, hit_record&amp; rec) const;

    public:
        vec3 center;
        double radius;
};

bool sphere::hit(const ray&amp; r, double t_min, double t_max, hit_record&amp; rec) const {
    vec3 oc = r.origin() - center;
    auto a = r.direction().length_squared();
    auto half_b = dot(oc, r.direction());
    auto c = oc.length_squared() - radius*radius;
    auto discriminant = half_b*half_b - a*c;

    if (discriminant &gt; 0) {
        auto root = sqrt(discriminant);
        auto temp = (-half_b - root)/a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.at(rec.t);
            rec.normal = (rec.p - center) / radius;
            return true;
        }
        temp = (-half_b + root) / a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.at(rec.t);
            rec.normal = (rec.p - center) / radius;
            return true;
        }
    }
    return false;
}


#endif
</code></pre>
<p>Une deuxième question que l'on pourrait se poser est la direction dans laquelle les normales doivent toujours pointer. Jusqu'à présent, la normale trouvée sera toujours dans la direction du centre du point d'intersection (la normale pointe vers l'extérieur). Si le rayon intersectionne la sphère depuis l'extérieur, la normale pointera à l'opposée du rayon. Si le rayon intersectionne la sphère depuis l'intérieur, la normale (qui pointe toujours vers l'extérieure) pointera vers le rayon. De plus, nous pouvons avoir la normale qui pointe toujours à l'opposée du rayon. Si le rayon est à l'extérieur de la sphère, la normale pointera à l'extérieure, mais si le rayon est à l'intérieur de la sphère, la normale pointera vers l'intérieur.</p>
<p><img src="img/directions_possibles_normale.jpg" alt="Les différentes directions possibles que peut prendre la normale" /></p>
<p>Nous devons choisir une de ses possibilités et s'y tenir, car nous voudrons éventuellement déterminer de quel côté de la surface un rayon provient. C'est important pour les objets qui sont rendus de façon différente de chaque côté, comme du texte qu'on écrirait sur une feuille de papier ou pour des objets qui ont un intérieur et un extérieur, comme des boules de verre.</p>
<p>Si nous décidons d'avoir les normales qui pointent toujours vers l'extérieur, nous avons besoin de déterminer de quel côté le rayon est pour le colorer. On peut le déterminer en comparant le rayon avec la normale. Si le rayon et la normale pointent dans la même direction, le rayon est à l'intérieur de l'objet. Ca peut être déterminé en prenant le produit scalaire des deux vecteurs : si le produit scalaire est positif, le rayon est à l'intérieur de la sphère.</p>
<pre><code class="language-cpp">if (dot(ray_direction, outward_normal) &gt; 0.0) {
    // ray is inside the sphere
    ...
} else {
    // ray is outside the sphere
    ...
}
</code></pre>
<p>Si nous décidons d'avoir les normales qui pointent dans la direction opposée au rayon, nous ne pouvons pas utiliser le produit scalaire pour déterminer de quel côté de la surface le rayon est. A la place, nous avons besoin de stocker l'information :</p>
<pre><code class="language-cpp">bool front_face;
if (dot(ray_direction, outward_normal) &gt; 0.0) {
    // ray is inside the sphere
    normal = -outward_normal;
    front_face = false;
}
else {
    // ray is outside the sphere
    normal = outward_normal;
    front_face = true;
}
</code></pre>
<p>La décision de savoir si vous souhaitez avoir les normales qui pointent toujours vers l'extérieure ou toujours à l'opposées du rayon est liée à la décision de savoir si vous voulez déterminer le côté de la surface au moment de la géométrie ou au moment de la coloration. Dans ce livre, nous avons plus de &quot;matériaux&quot; (type de surface) que nous aurons de types de géométrie, donc nous choisirons la voie de la facilité et nous déterminerons l'endroit/l'envers de la surface au moment de la géométrie. C'est juste une question de goût et vous trouverez les deux implémentations dans la littérature.</p>
<p>Nous ajoutons la variable booléenne <code>front_face</code> à la structure <code>hit_record</code>. Je sais que nous aurons besoin plus tard de flou de mouvement, donc j'ajoute également une variable <code>t</code> pour stocker le temps.</p>
<pre><code class="language-cpp">#ifndef HITTABLE_H
#define HITTABLE_H

#include &quot;ray.h&quot;

struct hit_record {
    vec3 p;
    vec3 normal;
    double t;
    bool front_face;

    inline void set_face_normal(const ray&amp; r, const vec3&amp; outward_normal) {
        front_face = dot(r.direction(), outward_normal) &lt; 0;
        normal = front_face ? outward_normal :-outward_normal;
    }
};

class hittable {
    public:
        virtual bool hit(const ray&amp; r, double t_min, double t_max, hit_record&amp; rec) const = 0;
};

#endif
</code></pre>
<p>Et ensuite, nous ajoutons la détermination du côté de la surface dans la classe :</p>
<pre><code class="language-cpp">bool sphere::hit(const ray&amp; r, double t_min, double t_max, hit_record&amp; rec) const {
    vec3 oc = r.origin() - center;
    auto a = r.direction().length_squared();
    auto half_b = dot(oc, r.direction());
    auto c = oc.length_squared() - radius*radius;
    auto discriminant = half_b*half_b - a*c;

    if (discriminant &gt; 0) {
        auto root = sqrt(discriminant);
        auto temp = (-half_b - root)/a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.at(rec.t);
            vec3 outward_normal = (rec.p - center) / radius;
            rec.set_face_normal(r, outward_normal);
            return true;
        }
        temp = (-half_b + root) / a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.at(rec.t);
            vec3 outward_normal = (rec.p - center) / radius;
            rec.set_face_normal(r, outward_normal);
            return true;
        }
    }
    return false;
}
</code></pre>
<p>Nous ajoutons une liste d'objets :</p>
<pre><code class="language-cpp">#ifndef HITTABLE_LIST_H
#define HITTABLE_LIST_H

#include &quot;hittable.h&quot;
#include &lt;memory&gt;
#include &lt;vector&gt;

using std::shared_ptr;
using std::make_shared;

class hittable_list: public hittable {
    public:
        hittable_list() {}
        hittable_list(shared_ptr&lt;hittable&gt; object) { add(object); }

        void clear() { objects.clear(); }
        void add(shared_ptr&lt;hittable&gt; object) { objects.push_back(object); }

        virtual bool hit(const ray&amp; r, double tmin, double tmax, hit_record&amp; rec) const;

    public:
        std::vector&lt;shared_ptr&lt;hittable&gt;&gt; objects;
};

bool hittable_list::hit(const ray&amp; r, double t_min, double t_max, hit_record&amp; rec) const {
    hit_record temp_rec;
    bool hit_anything = false;
    auto closest_so_far = t_max;

    for (const auto&amp; object : objects) {
        if (object-&gt;hit(r, t_min, closest_so_far, temp_rec)) {
            hit_anything = true;
            closest_so_far = temp_rec.t;
            rec = temp_rec;
        }
    }

    return hit_anything;
}

#endif
</code></pre>
<h2><a class="header" href="#quelques-nouvelles-fonctionnalités-du-c" id="quelques-nouvelles-fonctionnalités-du-c">Quelques nouvelles fonctionnalités du C++</a></h2>
<p>La classe <code>hittable_list</code> utilise deux fonctionnalités du C++ qui peuvent vous sembler inconnu si vous n'avez pas l'habitude de ce langage : <code>vector</code> et <code>shared_ptr</code>.</p>
<p><code>shared_ptr&lt;type&gt;</code> est un pointeur vers un type alloué, avec une sémantique de comptage de références. Chaque fois que vous attribuez sa valeur à un autre pointeur partagé (<code>shared_ptr</code>, généralement avec une affectation simple), le nombre de références est incrémenté. Lorsque les pointeurs partagés sortent de la portée (comme à la fin d'un bloc ou d'une fonction), le nombre de références est décrémenté. Une fois que le nombre atteint zéro, l'objet est supprimé de la mémoire.</p>
<p>Habituellement, un <code>shared_ptr</code> est d'abord initialisé avec un un objet nouvellement alloué :</p>
<pre><code class="language-cpp">shared_ptr&lt;double&gt; double_ptr = make_shared&lt;double&gt;(0.37);
shared_ptr&lt;vec3&gt;   vec3_ptr   = make_shared&lt;vec3&gt;(1.414214, 2.718281, 1.618034);
shared_ptr&lt;sphere&gt; sphere_ptr = make_shared&lt;sphere&gt;(vec3(0,0,0), 1.0);
</code></pre>
<p><code>make_shared&lt;thing&gt;(thing_constructor_params ...)</code> alloue une nouvelle instance du type <code>thing</code> en utilisant les paramètres de constructeur. Cette fonction retourne un <code>shared_ptr&lt;thing&gt;</code>.</p>
<p>Puisque le type peut automatiquement être inféré par le type de retour de <code>make_shared&lt;type&gt;(...)</code>, les lignes au-dessus peuvent être reécrites plus simplement en utilisant le mot-clé <code>auto</code> :</p>
<pre><code class="language-cpp">auto double_ptr = make_shared&lt;double&gt;(0.37);
auto vec3_ptr   = make_shared&lt;vec3&gt;(1.414214, 2.718281, 1.618034);
auto sphere_ptr = make_shared&lt;sphere&gt;(vec3(0,0,0), 1.0);
</code></pre>
<p>Nous utiliserons ces pointeurs partagés dans notre code, car ça permet à plusieurs géométries de partager une même instance (par exemple, un lot de sphères qui utilise le même matériau/texture) et parce que ça rend la gestion de la mémoire automatique et plus facile à comprendre.</p>
<p><code>std::shared_ptr</code> est inclus avec le header <code>&lt;memory&gt;</code>.</p>
<p>La deuxième fonctionnalité du C++ qui peut vous sembler non familiaire est le <code>std::vector</code>. C'est une sorte de tableau générique. Dans le code au-dessus, nous utilisons une collection de pointeurs vers <code>hittable</code>. <code>std::vector</code> s'aggrandie automatiquement à chaque fois qu'une valeur est ajoutée : <code>objects.push_back(object)</code> ajoute une valeur à la fin du <code>std::vector</code>.</p>
<p><code>std::vector</code> est inclus avec le header <code>&lt;vector&gt;</code>.</p>
<p>Finalement, l'instruction <code>using</code> indique au compilateur que nous obtenons <code>shared_ptr</code> et <code>make_shared</code> depuis la librairie standard <code>std</code>, donc nous n'avons pas besoin de les préfixer avec <code>std::</code> à chaque fois que nous y faisons référence.</p>
<h2><a class="header" href="#constantes-usuelles-et-fonctions-utilitaires" id="constantes-usuelles-et-fonctions-utilitaires">Constantes usuelles et fonctions utilitaires</a></h2>
<p>Nous avons besoin de quelques constantes mathématiques donc nous les définissons dans un fichier d'en-tête qui leurs sont propres. Pour l'instant, nous n'avons besoin que de la valeur infinie, mais nous allons également y définir Pi. Nous allons également placer des fonctions utilitaires dans l'en-tête <em>rtweekend.h</em> .</p>
<pre><code class="language-cpp">#ifndef RTWEEKEND_H
#define RTWEEKEND_H

#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;limits&gt;
#include &lt;memory&gt;


// Usings

using std::shared_ptr;
using std::make_shared;

// Constants

const double infinity = std::numeric_limits&lt;double&gt;::infinity();
const double pi = 3.1415926535897932385;

// Utility Functions

inline double degrees_to_radians(double degrees) {
    return degrees * pi / 180;
}

inline double ffmin(double a, double b) { return a &lt;= b ? a : b; }
inline double ffmax(double a, double b) { return a &gt;= b ? a : b; }

// Common Headers

#include &quot;ray.h&quot;
#include &quot;vec3.h&quot;

#endif
</code></pre>
<p>Et le nouveau <code>main</code> :</p>
<pre><code class="language-cpp">#include &quot;rtweekend.h&quot;

#include &quot;hittable_list.h&quot;
#include &quot;sphere.h&quot;

#include &lt;iostream&gt;
vec3 ray_color(const ray&amp; r, const hittable&amp; world) {
    hit_record rec;
    if (world.hit(r, 0, infinity, rec)) {
        return 0.5 * (rec.normal + vec3(1,1,1));
    }
    vec3 unit_direction = unit_vector(r.direction());
    auto t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);
}

int main() {
    const int image_width = 200;
    const int image_height = 100;

    std::cout &lt;&lt; &quot;P3\n&quot; &lt;&lt; image_width &lt;&lt; ' ' &lt;&lt; image_height &lt;&lt; &quot;\n255\n&quot;;

    vec3 lower_left_corner(-2.0, -1.0, -1.0);
    vec3 horizontal(4.0, 0.0, 0.0);
    vec3 vertical(0.0, 2.0, 0.0);
    vec3 origin(0.0, 0.0, 0.0);

    hittable_list world;
    world.add(make_shared&lt;sphere&gt;(vec3(0,0,-1), 0.5));
    world.add(make_shared&lt;sphere&gt;(vec3(0,-100.5,-1), 100));

    for (int j = image_height-1; j &gt;= 0; --j) {
        std::cerr &lt;&lt; &quot;\rScanlines remaining: &quot; &lt;&lt; j &lt;&lt; ' ' &lt;&lt; std::flush;
        for (int i = 0; i &lt; image_width; ++i) {
            auto u = double(i) / image_width;
            auto v = double(j) / image_height;
            ray r(origin, lower_left_corner + u*horizontal + v*vertical);

            vec3 color = ray_color(r, world);

            color.write_color(std::cout);
        }
    }

    std::cerr &lt;&lt; &quot;\nDone.\n&quot;;
}
</code></pre>
<p>Ce qui nous donne l'image suivante qui est une visualisation de où se situe les normales sur la surface de la sphère. C'est souvent une bonne façon pour détecter des problèmes sur un modèle 3D.</p>
<p><img src="img/sphere_normales_sol.png" alt="Rendu d'une sphère avec ses normales colorées et un sol" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ajouter_une_sphere.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="antialiasing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ajouter_une_sphere.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="antialiasing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
